var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import deprecated from 'react-prop-types/lib/deprecated';
import isRequiredForA11y from 'react-prop-types/lib/isRequiredForA11y';

import { SPACE } from '../constants/keyCodes';
import getField from '../utils/getField';
import themeColors from '../utils/themeColors';
import oneRequiredForA11y from '../utils/PropTypes/oneRequiredForA11y';
import capitalizeFirst from '../utils/StringUtils/capitalizeFirst';
import AccessibleFakeInkedButton from '../Helpers/AccessibleFakeInkedButton';
import FontIcon from '../FontIcons/FontIcon';
import SwitchTrack from './SwitchTrack';

/**
 * Prevents a second warning from appearing when using the deprecated or a11y required
 * props by using the `__superSecretProp`.... So secret!
 */
function preventDouble(validator) {
  return function validate(props, propName) {
    for (var _len = arguments.length, others = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      others[_key - 2] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName].concat(others));
    if (err && props.__superSecreteProp) {
      err = null;
    }

    return err;
  };
}

/**
 * The `SelectionControl` component is used to render any of the `Radio`, `Checkbox`, or `Switch`
 * selection control type. This component might eventually replace all three since they use this
 * anyways. I am not sure yet though.
 */

var SelectionControl = function (_PureComponent) {
  _inherits(SelectionControl, _PureComponent);

  function SelectionControl(props) {
    _classCallCheck(this, SelectionControl);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setInput = function (input) {
      _this._input = input;
    };

    _this._setControl = function (control) {
      _this._control = control;
    };

    _this._setContainer = function (container) {
      _this._container = container;
    };

    _this._getIcon = function () {
      var _this$props = _this.props,
          checkedIcon = _this$props.checkedIcon,
          uncheckedIcon = _this$props.uncheckedIcon,
          type = _this$props.type;

      var checked = getField(_this.props, _this.state, 'checked');
      if (checkedIcon || uncheckedIcon) {
        return checked ? checkedIcon : uncheckedIcon;
      }

      var prefix = (checked ? '' : 'un') + 'checked' + capitalizeFirst(type) + 'Icon';
      var iconClassName = _this.props[prefix + 'ClassName'];
      var children = _this.props[prefix + 'Children'];

      if (iconClassName || children) {
        return React.createElement(
          FontIcon,
          { iconClassName: iconClassName, inherit: true },
          children
        );
      }

      var icon = _this.props[prefix];
      return icon ? React.cloneElement(icon, { inherit: true }) : null;
    };

    _this._handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      var key = e.which || e.keyCode;
      if (key === SPACE) {
        _this._input.click();
      }
    };

    _this._handleChange = function (e) {
      var _this$props2 = _this.props,
          type = _this$props2.type,
          onChange = _this$props2.onChange;

      var checked = !getField(_this.props, _this.state, 'checked');
      if (onChange) {
        onChange(type === 'radio' ? e.target.value : checked, e);
      }

      if (typeof _this.props.checked === 'undefined') {
        _this.setState({ checked: checked });
      }
    };

    _this.state = {};
    if (typeof props.checked === 'undefined') {
      _this.state.checked = !!props.defaultChecked;
    }
    return _this;
  }

  /**
   * Gets the current checked value from the selection control. This is used when you have
   * an uncontrolled selection control and simply need the checked state from a ref callback.
   *
   * @return {boolean} the checked state for the selection control.\
   */


  SelectionControl.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        style = _props.style,
        className = _props.className,
        inline = _props.inline,
        type = _props.type,
        name = _props.name,
        value = _props.value,
        disabled = _props.disabled,
        labelBefore = _props.labelBefore,
        tabIndex = _props.tabIndex,
        inkDisabled = _props.inkDisabled,
        disabledInteractions = _props.disabledInteractions,
        ariaLabel = _props['aria-label'],
        ariaLabelledBy = _props['aria-labelledby'],
        ariaDescribedBy = _props['aria-describedby'],
        propLabel = _props.label,
        propChildren = _props.checked,
        onChange = _props.onChange,
        tooltip = _props.tooltip,
        checkedCheckboxIcon = _props.checkedCheckboxIcon,
        uncheckedCheckboxIcon = _props.uncheckedCheckboxIcon,
        checkedRadioIcon = _props.checkedRadioIcon,
        uncheckedRadioIcon = _props.uncheckedRadioIcon,
        __superSecreteProp = _props.__superSecreteProp,
        checkedIcon = _props.checkedIcon,
        uncheckedIcon = _props.uncheckedIcon,
        checkedRadioIconChildren = _props.checkedRadioIconChildren,
        checkedRadioIconClassName = _props.checkedRadioIconClassName,
        uncheckedRadioIconChildren = _props.uncheckedRadioIconChildren,
        uncheckedRadioIconClassName = _props.uncheckedRadioIconClassName,
        checkedCheckboxIconChildren = _props.checkedCheckboxIconChildren,
        checkedCheckboxIconClassName = _props.checkedCheckboxIconClassName,
        uncheckedCheckboxIconChildren = _props.uncheckedCheckboxIconChildren,
        uncheckedCheckboxIconClassName = _props.uncheckedCheckboxIconClassName,
        props = _objectWithoutProperties(_props, ['id', 'style', 'className', 'inline', 'type', 'name', 'value', 'disabled', 'labelBefore', 'tabIndex', 'inkDisabled', 'disabledInteractions', 'aria-label', 'aria-labelledby', 'aria-describedby', 'label', 'checked', 'onChange', 'tooltip', 'checkedCheckboxIcon', 'uncheckedCheckboxIcon', 'checkedRadioIcon', 'uncheckedRadioIcon', '__superSecreteProp', 'checkedIcon', 'uncheckedIcon', 'checkedRadioIconChildren', 'checkedRadioIconClassName', 'uncheckedRadioIconChildren', 'uncheckedRadioIconClassName', 'checkedCheckboxIconChildren', 'checkedCheckboxIconClassName', 'uncheckedCheckboxIconChildren', 'uncheckedCheckboxIconClassName']);

    var checked = getField(this.props, this.state, 'checked');
    var isSwitch = type === 'switch';
    var labelId = this.props.label && id + '-label';
    var label = this.props.label && React.createElement(
      'span',
      { id: labelId },
      this.props.label
    );

    var control = void 0;
    if (isSwitch) {
      control = React.createElement(SwitchTrack, {
        disabled: disabled,
        checked: checked,
        'aria-label': ariaLabel,
        'aria-labelledby': ariaLabelledBy || labelId
      });
    } else {
      control = React.createElement(
        AccessibleFakeInkedButton,
        {
          inkDisabled: inkDisabled,
          disabledInteractions: disabledInteractions,
          role: type,
          className: cn('md-selection-control-toggle md-btn md-btn--icon', themeColors({
            disabled: disabled,
            hint: !checked,
            secondary: checked
          })),
          'aria-checked': checked,
          'aria-label': ariaLabel,
          'aria-labelledby': ariaLabelledBy || labelId,
          'aria-describedby': ariaDescribedBy,
          tabIndex: tabIndex,
          disabled: disabled
        },
        tooltip,
        this._getIcon()
      );
    }

    return React.createElement(
      'div',
      _extends({}, props, {
        style: style,
        className: cn('md-selection-control-container', {
          'md-selection-control-container--inline': inline,
          'md-switch-container': isSwitch
        }, className),
        onKeyDown: this._handleKeyDown
      }),
      React.createElement('input', {
        ref: this._setInput,
        id: id,
        type: isSwitch ? 'checkbox' : type,
        checked: checked,
        onChange: this._handleChange,
        disabled: disabled,
        className: 'md-selection-control-input',
        name: name,
        value: value,
        'aria-hidden': true
      }),
      React.createElement(
        'label',
        {
          htmlFor: id,
          className: cn('md-selection-control-label', {
            'md-pointer--hover': !disabled
          }, themeColors({ disabled: disabled, text: !disabled }))
        },
        labelBefore && label,
        control,
        !labelBefore && label
      )
    );
  };

  _createClass(SelectionControl, [{
    key: 'checked',
    get: function get() {
      return getField(this.props, this.state, 'checked');
    }
  }]);

  return SelectionControl;
}(PureComponent);

SelectionControl.propTypes = {
  /**
   * An id to use with the selection control. This is used for accessibility and so that the label
   * triggers the selection control toggle.
   */
  id: preventDouble(isRequiredForA11y(PropTypes.oneOfType([PropTypes.string, PropTypes.number]))),

  /**
   * An optional label to apply to the checkbox when there is no visible label.
   */
  'aria-label': oneRequiredForA11y(PropTypes.string, 'label', 'aria-labelledby'),

  /**
   * An optional id that points to a label for the selection control when there is no visible label.
   */
  'aria-labelledby': PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * An optional id of an element that describes this selection control.
   * In the case of a fieldset, this should be the id of the fieldset legend which ensures
   * screen readers provides additional context about the selection control
   */
  'aria-describedby': PropTypes.string,

  /**
   * An optional style to apply to the selection control's container.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the selection control's container.
   */
  className: PropTypes.string,

  /**
   * The type of selection control to render.
   */
  type: PropTypes.oneOf(['checkbox', 'radio', 'switch']).isRequired,

  /**
   * A label to display with the selection control. This is required for accessibility and triggering
   * the toggle.
   */
  label: PropTypes.node,

  /**
   * Boolean if the label should appear before the checkbox/radio icon or switch.
   */
  labelBefore: PropTypes.bool,

  /**
   * A name to use for the `SelectionControl`. This is required for accessibility. If the `type`
   * is a `checkbox` and it is part of a group, it is recommended to make this a string ending
   * in `[]` so that the value can be found from `document.querySelector('input[name="someName[]"]').value`.
   */
  name: preventDouble(isRequiredForA11y(PropTypes.oneOfType([PropTypes.number, PropTypes.string]))),

  /**
   * Boolean if the `Radio` is disabled.
   */
  disabled: PropTypes.bool,

  /**
   * A function to call when the `SelectionControl` triggers the `change` event. The `onChange`
   * callback will either include:
   * - the currently changed radio's value
   * - the next checked state for the `Switch` or `Checkbox`.
   *
   * as the first parameter followed by the change event.
   *
   * ```js
   * // Radio
   * onChange(changeEvent.target.value, changeEvent);
   *
   * // Checkbox or Switch
   * onChange(changeEvent.target.checked, changeEvent);
   * ```
   */
  onChange: PropTypes.func,

  /**
   * An optional function to call when the `keydown` event is triggered.
   */
  onKeyDown: PropTypes.func,

  /**
   * The value for the `SelectionControl`. It is not required for `Checkbox` and `Switch`,
   * but it is recommended.
   */
  value: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string]),

  /**
   * A boolean if the `SelectionControl` is currently checked. This _really_ makes the `onChange`
   * prop required, but since there are cases you might want to have the `onChange` listener on a
   * `fieldset` or something above the component, it is never set to `required`. It will however
   * prevent updates if there is no change listener.
   */
  checked: PropTypes.bool,

  /**
   * Boolean if the `Checkbox` or `Switch` are checked by default. This prop is invalid for a
   * `Radio`.
   */
  defaultChecked: PropTypes.bool,

  /**
   * Boolean if the `SelectionControl` should be displayed inline instead of a block.
   */
  inline: PropTypes.bool,

  /**
   * The icon to use for a checked `checkbox` selection control.
   */
  checkedCheckboxIcon: PropTypes.element,

  /**
   * The icon to use for an unchecked `checkbox` selection control.
   */
  uncheckedCheckboxIcon: PropTypes.element,

  /**
   * The icon to use for a checked `radio` selection control.
   */
  checkedRadioIcon: PropTypes.element,

  /**
   * The icon to use for an unchecked `radio` selection control.
   */
  uncheckedRadioIcon: PropTypes.element,

  /**
   * An optional tooltip to render with the control. This is only used if you inject the
   * tooltip manually yourself.
   *
   * `const TooltippedSelectionControl = injectTooltip(SelectionControl);`
   */
  tooltip: PropTypes.node,

  /**
   * Boolean if the ink should be disabled for radios or checkboxes.
   *
   * @see {@link Inks#inkDisabled}
   */
  inkDisabled: PropTypes.bool,

  /**
   * An optional list of ink interactions that should be disabled.
   *
   * @see {@link Inks#disabledInteractions}
   */
  disabledInteractions: PropTypes.arrayOf(PropTypes.oneOf(['keyboard', 'touch', 'mouse'])),

  /**
   * An optional tab index to apply to the selection control.
   */
  tabIndex: PropTypes.number,

  checkedIcon: preventDouble(deprecated(PropTypes.node, 'Use the `checkedCheckboxIconChildren` and `checkedCheckboxIconClassName`  or the ' + '`checkedRadioIconChildren` and `checkedRadioIconClassName` props instead')),
  uncheckedIcon: preventDouble(deprecated(PropTypes.node, 'Use the `uncheckedCheckboxIconChildren` and `uncheckedCheckboxIconClassName`  or the ' + '`uncheckedRadioIconChildren` and `uncheckedRadioIconClassName` props instead')),
  checkedCheckboxIconChildren: deprecated(PropTypes.node, 'Use the `checkedCheckboxIcon` prop instead'),
  checkedCheckboxIconClassName: deprecated(PropTypes.string, 'Use the `checkedCheckboxIcon` prop instead'),
  uncheckedCheckboxIconChildren: deprecated(PropTypes.node, 'Use the `uncheckedCheckboxIcon` prop instead'),
  uncheckedCheckboxIconClassName: deprecated(PropTypes.string, 'Use the `uncheckedCheckboxIcon` prop instead'),
  checkedRadioIconChildren: deprecated(PropTypes.node, 'Use the `checkedRadioIcon` prop instead'),
  checkedRadioIconClassName: deprecated(PropTypes.string, 'Use the `checkedRadioIcon` prop instead'),
  uncheckedRadioIconChildren: deprecated(PropTypes.node, 'Use the `uncheckedRadioIcon` prop instead'),
  uncheckedRadioIconClassName: deprecated(PropTypes.string, 'Use the `uncheckedRadioIcon` prop instead'),

  /* maybe removed once upgrade again? */
  __superSecreteProp: PropTypes.bool
};
SelectionControl.defaultProps = {
  checkedCheckboxIcon: React.createElement(
    FontIcon,
    null,
    'check_box'
  ),
  uncheckedCheckboxIcon: React.createElement(
    FontIcon,
    null,
    'check_box_outline_blank'
  ),
  checkedRadioIcon: React.createElement(
    FontIcon,
    null,
    'radio_button_checked'
  ),
  uncheckedRadioIcon: React.createElement(
    FontIcon,
    null,
    'radio_button_unchecked'
  )
};
export default SelectionControl;