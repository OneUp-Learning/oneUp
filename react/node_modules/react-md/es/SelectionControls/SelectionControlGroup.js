var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';

import { UP, DOWN, LEFT, RIGHT } from '../constants/keyCodes';
import getField from '../utils/getField';
import minMaxLoop from '../utils/NumberUtils/minMaxLoop';
import controlled from '../utils/PropTypes/controlled';
import SelectionControl from './SelectionControl';

/**
 * A custom PropTypes validator to make sure that each `control` in the `controls` prop
 * contains the given `propName`, or the `SelectionControlGroup` has defined that prop.
 */
function requiredByAllControls(validator) {
  return function validate(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName, component].concat(others));

    if (!err && typeof props[propName] === 'undefined') {
      var invalids = props.controls.filter(function (c) {
        return !c[propName];
      }).map(function (_, i) {
        return i;
      });
      if (invalids.length) {
        var invalidPrefix = invalids.length === props.controls.length ? 'All `controls`' : 'The `controls` at indexes `' + invalids.join('`, `') + '`';
        var invalidMsg = invalidPrefix + ' are missing the `' + propName + '` prop.';

        err = new Error('The `' + propName + '` prop is required to make `' + component + '` accessible for users of ' + ('assistive technologies such as screen readers. Either add the `' + propName + '` to the `' + component + '` ') + ('or add the `' + propName + '` to each `control` in the `controls` prop. ' + invalidMsg));
      }
    }

    return err;
  };
}

/**
 * The `SelectionControlGroup` component is used to simplify the generation of a list
 * of `SelectionControl`. Any common props are extracted to this component and passed
 * to the `SelectionControl`.
 */

var SelectionControlGroup = function (_PureComponent) {
  _inherits(SelectionControlGroup, _PureComponent);

  function SelectionControlGroup(props) {
    _classCallCheck(this, SelectionControlGroup);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setGroup = function (group) {
      _this._group = group;
    };

    _this._handleChange = function (e) {
      var value = e.target.value;
      if (_this.props.type === 'checkbox') {
        var checked = e.target.checked;

        var currentValue = getField(_this.props, _this.state, 'value');
        var existsIndex = currentValue.indexOf(value);
        if (existsIndex === -1 && checked) {
          value = '' + (currentValue ? currentValue + ',' : '') + value;
        } else if (existsIndex > -1 && !checked) {
          value = currentValue.replace(new RegExp(value + ',?'), '');
        } else {
          value = currentValue;
        }
      }

      if (_this.props.onChange) {
        _this.props.onChange(value, e);
      }

      if (typeof _this.props.value === 'undefined') {
        _this.setState({ value: value });
      }
    };

    _this._handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      var key = e.which || e.keyCode;
      var dec = key === UP || key === LEFT;
      var inc = key === DOWN || key === RIGHT;
      if (!_this._group || !dec && !inc) {
        return;
      }

      e.preventDefault();
      var radios = _this._group.querySelectorAll('*[role="radio"]');
      _this._activeIndex = minMaxLoop(_this._activeIndex, 0, radios.length - 1, inc);
      radios[_this._activeIndex].focus();
      var value = _this.props.controls[_this._activeIndex].value;

      if (getField(_this.props, _this.state, 'value') !== value) {
        if (_this.props.onChange) {
          _this.props.onChange(value, e);
        }

        if (typeof _this.props.value === 'undefined') {
          _this.setState({ value: value });
        }
      }
    };

    var radio = props.type === 'radio';
    _this.state = {};

    if (typeof props.value === 'undefined') {
      var value = props.defaultValue;

      if (typeof value === 'undefined') {
        value = radio ? props.controls[0].value : '';
      }

      _this.state.value = value;
    }

    var groupValue = getField(props, _this.state, 'value');
    _this._activeIndex = -1;
    props.controls.some(function (_ref, i) {
      var value = _ref.value;

      if (value === groupValue) {
        _this._activeIndex = i;
      }

      return _this._activeIndex > -1;
    });
    return _this;
  }

  SelectionControlGroup.prototype._isChecked = function _isChecked(value, controlValue, type) {
    return type === 'radio' ? value === controlValue : value.split(',').indexOf(controlValue) !== -1;
  };

  SelectionControlGroup.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        id = _props.id,
        name = _props.name,
        type = _props.type,
        label = _props.label,
        labelClassName = _props.labelClassName,
        className = _props.className,
        controlStyle = _props.controlStyle,
        controlClassName = _props.controlClassName,
        Component = _props.component,
        LabelComponent = _props.labelComponent,
        inline = _props.inline,
        disabled = _props.disabled,
        checkedRadioIcon = _props.checkedRadioIcon,
        uncheckedRadioIcon = _props.uncheckedRadioIcon,
        checkedCheckboxIcon = _props.checkedCheckboxIcon,
        uncheckedCheckboxIcon = _props.uncheckedCheckboxIcon,
        ControlComponent = _props.controlComponent,
        propValue = _props.value,
        propControls = _props.controls,
        defaultValue = _props.defaultValue,
        props = _objectWithoutProperties(_props, ['id', 'name', 'type', 'label', 'labelClassName', 'className', 'controlStyle', 'controlClassName', 'component', 'labelComponent', 'inline', 'disabled', 'checkedRadioIcon', 'uncheckedRadioIcon', 'checkedCheckboxIcon', 'uncheckedCheckboxIcon', 'controlComponent', 'value', 'controls', 'defaultValue']);

    var value = getField(this.props, this.state, 'value');
    var radio = type === 'radio';

    var controls = this.props.controls.map(function (control, i) {
      var style = control.style;
      if (controlStyle) {
        style = style ? _extends({}, controlStyle, style) : controlStyle;
      }

      var checked = _this2._isChecked(value, control.value, type);
      var controlProps = _extends({
        id: '' + id + i,
        key: 'control' + i,
        name: '' + name + (type === 'checkbox' ? '[]' : ''),
        type: type,
        inline: inline,
        disabled: disabled,
        checked: checked,
        tabIndex: !radio || checked || i === 0 && _this2._activeIndex === -1 ? undefined : -1,
        checkedRadioIcon: checkedRadioIcon,
        uncheckedRadioIcon: uncheckedRadioIcon,
        checkedCheckboxIcon: checkedCheckboxIcon,
        uncheckedCheckboxIcon: uncheckedCheckboxIcon,
        'aria-describedby': id + '-group-label'
      }, control, {
        style: style,
        className: cn(controlClassName, control.className)
      });

      return React.createElement(ControlComponent, controlProps);
    });

    var ariaLabel = void 0;
    if (label) {
      ariaLabel = React.createElement(
        LabelComponent,
        { className: labelClassName, id: id + '-group-label' },
        label
      );
    }

    return React.createElement(
      Component,
      _extends({}, props, {
        ref: this._setGroup,
        className: cn('md-selection-control-group', className),
        onChange: this._handleChange,
        onKeyDown: radio ? this._handleKeyDown : null
      }),
      ariaLabel,
      controls
    );
  };

  return SelectionControlGroup;
}(PureComponent);

SelectionControlGroup.propTypes = {
  /**
   * An optional style to apply to the container.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the container.
   */
  className: PropTypes.string,

  /**
   * An optional style to apply to every `SelectionControl`. This will be merged with any `style`
   * that a `control` might have.
   */
  controlStyle: PropTypes.object,

  /**
   * An optional className to apply to every `SelectionControl`. This will be merged with any
   * `className` that a `control` might have.
   */
  controlClassName: PropTypes.string,

  /**
   * An optional base id to apply to each `SelectionControl`. When this is included, the id for
   * each control will start with this and end with their current index. If this is omitted,
   * each `control` in the `controls` prop *must* have an `id` prop. This is required for
   * accessibility.
   */
  id: requiredByAllControls(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),

  /**
   * The type to apply to each `SelectionControl` in the group. Only `checkbox` and `radio` is
   * valid for a grouping.
   */
  type: PropTypes.oneOf(['checkbox', 'radio']).isRequired,

  /**
   * The component to render the `SelectionControlGroup` in. This can only be a valid dom element
   * since it relies on the ref callback to add keyboard accessibility.
   */
  component: PropTypes.string.isRequired,

  /**
   * An optional label to display above the group of `SelectionControl`s.
   */
  label: PropTypes.node,

  /**
   * An optional className to apply to the node surrounding the `label` prop.
   */
  labelClassName: PropTypes.string,

  /**
   * The component to render each item in the `controls` list as. By default, this will be the
   * `SelectionControl` component but you can change this to any React component that accepts
   * the selection control props. It is currently provided:
   *
   * ```js
   * const controlProps = {
   *   id: `${id}${i}`,
   *   key: `control${i}`,
   *   name: `${name}${type === 'checkbox' ? '[]' : ''}`,
   *   type,
   *   inline,
   *   disabled,
   *   checked,
   *   tabIndex: !radio || checked || (i === 0 && this._activeIndex === -1) ? undefined : -1,
   *   checkedRadioIcon,
   *   uncheckedRadioIcon,
   *   checkedCheckboxIcon,
   *   uncheckedCheckboxIcon,
   *   ...control,
   *   style,
   *   className: cn(controlClassName, control.className),
   * };
   * ```
   */
  controlComponent: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,

  /**
   * The component to render the optional `label` in.
   */
  labelComponent: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,

  /**
   * An optional function to call when any `SelectionControl`'s `checked` state is changed
   * in the group. If the `type` of the group is `radio`, the `value` of the `checked` radio
   * will be given in the callback. If the `type` of the group is `checkbox`, a comma-delimited
   * string of all `checked` checkboxes values will be given.
   *
   * ```js
   * // checkbox
   * onChange('Alpha,Omega', changeEvent);
   *
   * // radio
   * onChange('Omega', changeEvent);
   * ```
   */
  onChange: PropTypes.func,

  /**
   * A name to use for each `SelectionControl` in the group. If the `type` of the group is
   * `checkbox`, the name will be updated to be an array name so that using
   * `document.querySelector('input[name="yourName[]"].value` will give the comma-delimited
   * string of checked checkboxes.
   *
   * It is either required to have this prop set or every `control` in the `controls` prop to
   * have the `name` prop.
   */
  name: requiredByAllControls(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),

  /**
   * The default value for the `SelectionControlGroup`. This can either be a single value
   * or a comma-delimited string of checkbox values. When the `type` of the group is `radio`
   * and the group is uncontrolled, it is recommended to set this prop. Otherwise the first
   * value of the `controls` prop will be used as the default value.
   */
  defaultValue: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string]),

  /**
   * An optional value to use for the `SelectionControlGroup`. This will make the component
   * controlled and require the `onChange` prop to be defined. Like the `defaultValue`, this
   * can either be a single value or a comma-delimited list of checkbox values.
   */
  value: controlled(PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string]), 'onChange'),

  /**
   * A list of objects to create the `SelectionControl` components. The shape of the object
   * is the `propTypes` of the `SelectionControl` component, except that `value` prop is
   * now required.
   *
   * The `SelectionControl` will inherit any inheritable props from the `SelectionControlGroup`.
   */
  controls: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    label: PropTypes.node.isRequired,
    value: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string]).isRequired
  })).isRequired,

  /**
   * Boolean if the `SelectionControl` should be displayed inline.
   */
  inline: PropTypes.bool,

  /**
   * Boolean if all the selection controls in the group are disabled.
   */
  disabled: PropTypes.bool,

  /**
   * An optional function to call when the keydown event is triggered.
   */
  onKeyDown: PropTypes.func,

  /**
   * An icon to use for a checked `radio` control. This will be applied to each
   * control that has a `type="radio"` in the `controls` list. This is just a simpler
   * way of applying the custom icons for each radio in the list.
   *
   * This will default to the `checkedRadioIcon` on the `SelectionControl`.
   *
   * @see {@link #controls}
   * @see {@link #uncheckedRadioIcon}
   * @see {@link SelectionControls/SelectionControls#checkedRadioIcon}
   * @see {@link SelectionControls/SelectionControls#uncheckedRadioIcon}
   */
  checkedRadioIcon: PropTypes.node,

  /**
   * An icon to use for an unchecked `radio` control. This will be applied to each
   * control that has a `type="radio"` in the `controls` list. This is just a simpler
   * way of applying the custom icons for each radio in the list.
   *
   * This will default to the `uncheckedRadioIcon` on the `SelectionControl`.
   *
   * @see {@link #controls}
   * @see {@link #checkedRadioIcon}
   * @see {@link SelectionControls/SelectionControls#checkedRadioIcon}
   * @see {@link SelectionControls/SelectionControls#uncheckedRadioIcon}
   */
  uncheckedRadioIcon: PropTypes.node,

  /**
   * An icon to use for a checked `checkbox` control. This will be applied to each
   * control that has a `type="checkbox"` in the `controls` list. This is just a simpler
   * way of applying the custom icons for each checkbox in the list.
   *
   * This will default to the `checkedCheckboxIcon` on the `SelectionControl`.
   *
   * @see {@link #controls}
   * @see {@link #uncheckedCheckboxIcon}
   * @see {@link SelectionControls/SelectionControls#checkedCheckboxIcon}
   * @see {@link SelectionControls/SelectionControls#uncheckedCheckboxIcon}
   */
  checkedCheckboxIcon: PropTypes.node,

  /**
   * An icon to use for an unchecked `checkbox` control. This will be applied to each
   * control that has a `type="checkbox"` in the `controls` list. This is just a simpler
   * way of applying the custom icons for each checkbox in the list.
   *
   * This will default to the `uncheckedCheckboxIcon` on the `SelectionControl`.
   *
   * @see {@link #controls}
   * @see {@link #checkedCheckboxIcon}
   * @see {@link SelectionControls/SelectionControls#checkedCheckboxIcon}
   * @see {@link SelectionControls/SelectionControls#uncheckedCheckboxIcon}
   */
  uncheckedCheckboxIcon: PropTypes.node
};
SelectionControlGroup.defaultProps = {
  component: 'fieldset',
  labelComponent: 'legend',
  labelClassName: 'md-subheading-1',
  controlComponent: SelectionControl
};
export default SelectionControlGroup;