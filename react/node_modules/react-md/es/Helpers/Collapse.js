var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent, Children, cloneElement } from 'react';
import PropTypes from 'prop-types';
import { findDOMNode } from 'react-dom';
import { Motion, spring } from 'react-motion';

/**
 * The `Collapse` component is used to animate a single child entering
 * or leaving. This uses the `react-motion` library to animate the height,
 * padding-top, and padding-bottom of an element when the `collapsed` prop
 * changes.
 */

var Collapse = function (_PureComponent) {
  _inherits(Collapse, _PureComponent);

  function Collapse(props) {
    _classCallCheck(this, Collapse);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setHeight = function (child) {
      if (_this._child && typeof _this._child.ref === 'function') {
        _this._child.ref(child);
      }

      var height = 0;
      var paddingTop = 0;
      var paddingBottom = 0;
      if (child !== null) {
        var node = findDOMNode(child);
        var cs = window.getComputedStyle(node);
        height = node.offsetHeight;
        paddingTop = parseInt(cs.getPropertyValue('padding-top'), 10);
        paddingBottom = parseInt(cs.getPropertyValue('padding-bottom'), 10);
      }

      height = Math.max(_this.props.minHeight, height);

      _this.setState({ height: height, paddingTop: paddingTop, paddingBottom: paddingBottom });
    };

    if (!props.collapsed) {
      _this.state = { initialOpen: true };
    } else {
      _this.state = {
        height: props.minHeight,
        paddingTop: 0,
        paddingBottom: 0
      };
    }
    return _this;
  }

  Collapse.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.state.initialOpen && nextProps.collapsed) {
      this.setState({ initialOpen: false });
    }
  };

  Collapse.prototype._spring = function _spring(collapsed, initialOpen, value, config) {
    var min = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    var nextValue = !collapsed ? Math.max(min, value) : min;
    if (initialOpen && !collapsed) {
      return nextValue;
    }

    return spring(nextValue, config);
  };

  Collapse.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        height = _state.height,
        paddingTop = _state.paddingTop,
        paddingBottom = _state.paddingBottom,
        initialOpen = _state.initialOpen;
    var _props = this.props,
        children = _props.children,
        collapsed = _props.collapsed,
        defaultStyle = _props.defaultStyle,
        motionStyle = _props.style,
        springConfig = _props.springConfig,
        animate = _props.animate,
        minHeight = _props.minHeight;


    if (!animate) {
      return collapsed ? null : children;
    }

    return React.createElement(
      Motion,
      {
        style: _extends({}, motionStyle, {
          height: this._spring(collapsed, initialOpen, height, springConfig, minHeight),
          paddingTop: this._spring(collapsed, initialOpen, paddingTop, springConfig),
          paddingBottom: this._spring(collapsed, initialOpen, paddingBottom, springConfig)
        }),
        defaultStyle: _extends({}, defaultStyle, {
          height: height,
          paddingTop: paddingTop,
          paddingBottom: paddingBottom
        })
      },
      function (style) {
        if (collapsed && !style.height) {
          return null;
        }

        var child = Children.only(children);
        _this2._child = child;
        var nextStyle = child.props.style;
        if (collapsed && (!minHeight || style.height !== minHeight) || style.height !== height) {
          nextStyle = _extends({}, child.props.style, style, {
            overflow: 'hidden'
          });
        }
        return cloneElement(child, {
          ref: !collapsed ? _this2._setHeight : null,
          style: nextStyle
        });
      }
    );
  };

  return Collapse;
}(PureComponent);

Collapse.propTypes = {
  /**
   * An optional style to merge with the `Motion` style.
   */
  style: PropTypes.object,

  /**
   * An optional default style to merge with the `Motion` default style.
   */
  defaultStyle: PropTypes.object,

  /**
   * Boolean if the children are currently collapsed.
   */
  collapsed: PropTypes.bool.isRequired,

  /**
   * A single child to collapse or expand.
   */
  children: PropTypes.element.isRequired,

  /**
   * The spring config to use for the animation.
   */
  springConfig: PropTypes.object.isRequired,

  /**
   * Boolean if the single child entering or leaving should be animated.
   */
  animate: PropTypes.bool,

  /**
   * The min height to apply for the collapse div.
   */
  minHeight: PropTypes.number.isRequired
};
Collapse.defaultProps = {
  animate: true,
  springConfig: {
    precision: 0.5
  },
  minHeight: 0
};
export default Collapse;