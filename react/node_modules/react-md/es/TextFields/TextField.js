var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent, Children, cloneElement } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import deprecated from 'react-prop-types/lib/deprecated';
import isRequiredForA11y from 'react-prop-types/lib/isRequiredForA11y';

import isValued from '../utils/isValued';
import getField from '../utils/getField';
import getTextWidth from '../utils/Positioning/getTextWidth';
import controlled from '../utils/PropTypes/controlled';
import invalidIf from '../utils/PropTypes/invalidIf';
import minNumber from '../utils/PropTypes/minNumber';
import addSuffix from '../utils/StringUtils/addSuffix';
import FontIcon from '../FontIcons/FontIcon';
import getDeprecatedIcon from '../FontIcons/getDeprecatedIcon';
import FloatingLabel from './FloatingLabel';
import TextFieldMessage from './TextFieldMessage';
import PasswordButton from './PasswordButton';
import InputField from './InputField';
import TextFieldDivider from './TextFieldDivider';

var DEFAULT_TEXT_FIELD_SIZE = 180;

var WILL_RECEIVE_KEYS = ['style', 'value', 'resize'];
var DID_UPDATE_KEYS = ['leftIcon', 'rightIcon', 'passwordIcon', 'inlineIndicator'];

/**
 * The `TextField` component can either be a single line `input` field or a multiline
 * `textarea` field. `FontIcon`s, messages, and password indicators can also be added
 * to this field.
 *
 * The optional mouse and touch events will be added to the entire container while the
 * text specific events will be added to the `input` or `textarea` tags.
 */

var TextField = function (_PureComponent) {
  _inherits(TextField, _PureComponent);

  function TextField(props) {
    _classCallCheck(this, TextField);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _initialiseProps.call(_this);

    var currentLength = _this._getLength(typeof props.value !== 'undefined' ? props.value : props.defaultValue);

    _this._canvas = null;
    var width = null;
    if (typeof props.resize !== 'undefined') {
      width = typeof props.resize.min === 'number' ? props.resize.min : DEFAULT_TEXT_FIELD_SIZE;
    }

    _this.state = {
      active: false,
      error: props.maxLength ? props.maxLength < currentLength : false,
      floating: isValued(props.defaultValue) || isValued(props.value),
      passwordVisible: props.passwordInitiallyVisible,
      currentLength: currentLength,
      styles: width ? _extends({ width: width }, props.style) : props.style
    };
    return _this;
  }

  TextField.prototype.componentDidMount = function componentDidMount() {
    var _props = this.props,
        value = _props.value,
        defaultValue = _props.defaultValue,
        resize = _props.resize,
        style = _props.style;

    var v = typeof value !== 'undefined' ? value : defaultValue;
    /* eslint-disable react/no-did-mount-set-state */
    if (resize) {
      // always want to set width on mount
      this.setState({ styles: _extends({ width: this._calcWidth(v, this.props) }, style) });
    }
  };

  TextField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    var value = nextProps.value,
        resize = nextProps.resize,
        style = nextProps.style;

    var nextState = {};
    if (value !== this.props.value) {
      nextState.error = this._isErrored(nextProps);
      nextState.floating = this._focus || isValued(value);
      nextState.currentLength = this._getLength(value);
    }

    if (WILL_RECEIVE_KEYS.some(function (key) {
      return _this2.props[key] !== nextProps[key];
    })) {
      if (!resize) {
        nextState.styles = style;
      } else {
        var width = this._calcWidth(value, nextProps);
        nextState.styles = _extends({ width: width }, style);
      }
    }

    this.setState(nextState);
  };

  TextField.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this3 = this;

    var _props2 = this.props,
        resize = _props2.resize,
        value = _props2.value,
        style = _props2.style;

    if (resize && DID_UPDATE_KEYS.some(function (key) {
      return _this3.props[key] !== prevProps[key];
    })) {
      var width = this._calcWidth(value, this.props);
      this.setState({ styles: _extends({ width: width }, style) }); // eslint-disable-line react/no-did-update-set-state
    }
  };

  /**
   * A helper function for getting the specific `input` field or the `textarea` in the `TextField`.
   * This is accessible if you use `refs`.
   *
   * Example:
   *
   * ```js
   * <TextField ref={field => this._field = field;} label="Hello" />;
   *
   * this._field.getField(); // `input` node
   * ```
   */


  /**
   * A helper function for focusing the `input` field or the `textarea` in the `TextField`.
   * This is accessibile if you use `refs`.
   * Example:
   *
   * ```js
   * <TextField ref={field => this._field = field;} label="Hello" />;
   *
   * this._field.focus();
   * ```
   */


  /**
   * A helper function for blurring the `input` field or the `textarea` in the `TextField`.
   * This is accessible if you use `refs`.
   * Example:
   *
   * ```js
   * <TextField ref={field => this._field = field;} label="Hello" />;
   *
   * this._field.blur();
   * ```
   */
  TextField.prototype.blur = function blur() {
    this._field.blur();
  };

  TextField.prototype._cloneIcon = function _cloneIcon(icon, active, error, disabled, stateful, block, dir) {
    if (!icon) {
      return icon;
    }

    try {
      var iconEl = Children.only(icon);
      return cloneElement(iconEl, {
        key: iconEl.key || 'icon-' + dir,
        disabled: stateful ? disabled : undefined,
        primary: stateful ? !error && active : undefined,
        error: stateful ? error : undefined,
        className: cn('md-text-field-icon', {
          'md-text-field-icon--positioned': !block
        }, iconEl.props.className)
      });
    } catch (e) {
      return icon;
    }
  };

  /**
   * A small utility function for calculating an inline-icon's width keeping the SVG Icons
   * in mind and any margin that gets applied for spacing.
   */


  TextField.prototype.render = function render() {
    var _state = this.state,
        currentLength = _state.currentLength,
        passwordVisible = _state.passwordVisible,
        styles = _state.styles;

    var _props3 = this.props,
        id = _props3.id,
        type = _props3.type,
        className = _props3.className,
        inputStyle = _props3.inputStyle,
        inputClassName = _props3.inputClassName,
        block = _props3.block,
        fullWidth = _props3.fullWidth,
        required = _props3.required,
        customSize = _props3.customSize,
        maxLength = _props3.maxLength,
        errorText = _props3.errorText,
        helpText = _props3.helpText,
        helpOnFocus = _props3.helpOnFocus,
        disabled = _props3.disabled,
        leftIconStateful = _props3.leftIconStateful,
        rightIconStateful = _props3.rightIconStateful,
        lineDirection = _props3.lineDirection,
        paddedBlock = _props3.paddedBlock,
        onDoubleClick = _props3.onDoubleClick,
        onTouchStart = _props3.onTouchStart,
        onTouchMove = _props3.onTouchMove,
        onTouchCancel = _props3.onTouchCancel,
        onTouchEnd = _props3.onTouchEnd,
        onMouseDown = _props3.onMouseDown,
        onMouseUp = _props3.onMouseUp,
        onMouseOver = _props3.onMouseOver,
        onMouseLeave = _props3.onMouseLeave,
        ink = _props3.ink,
        inlineIndicator = _props3.inlineIndicator,
        toolbar = _props3.toolbar,
        propPasswordIcon = _props3.passwordIcon,
        icon = _props3.icon,
        passwordIconChildren = _props3.passwordIconChildren,
        passwordIconClassName = _props3.passwordIconClassName,
        style = _props3.style,
        propLabel = _props3.label,
        propPlaceholder = _props3.placeholder,
        propError = _props3.error,
        propActive = _props3.active,
        propFloating = _props3.floating,
        propLeftIcon = _props3.leftIcon,
        propRightIcon = _props3.rightIcon,
        onClick = _props3.onClick,
        onChange = _props3.onChange,
        onBlur = _props3.onBlur,
        onFocus = _props3.onFocus,
        resize = _props3.resize,
        adjustMinWidth = _props3.adjustMinWidth,
        propFloatingLabel = _props3.floatingLabel,
        props = _objectWithoutProperties(_props3, ['id', 'type', 'className', 'inputStyle', 'inputClassName', 'block', 'fullWidth', 'required', 'customSize', 'maxLength', 'errorText', 'helpText', 'helpOnFocus', 'disabled', 'leftIconStateful', 'rightIconStateful', 'lineDirection', 'paddedBlock', 'onDoubleClick', 'onTouchStart', 'onTouchMove', 'onTouchCancel', 'onTouchEnd', 'onMouseDown', 'onMouseUp', 'onMouseOver', 'onMouseLeave', 'ink', 'inlineIndicator', 'toolbar', 'passwordIcon', 'icon', 'passwordIconChildren', 'passwordIconClassName', 'style', 'label', 'placeholder', 'error', 'active', 'floating', 'leftIcon', 'rightIcon', 'onClick', 'onChange', 'onBlur', 'onFocus', 'resize', 'adjustMinWidth', 'floatingLabel']);

    var _props4 = this.props,
        label = _props4.label,
        placeholder = _props4.placeholder,
        error = _props4.error,
        active = _props4.active,
        floating = _props4.floating,
        leftIcon = _props4.leftIcon,
        rightIcon = _props4.rightIcon;

    active = active || this.state.active;
    error = error || this.state.error;
    floating = floating || this.state.floating;

    if (required) {
      if (label) {
        label = addSuffix(label, '*');
      }

      if (placeholder && !label) {
        placeholder = addSuffix(placeholder, '*');
      }
    }

    if (label && !floating) {
      placeholder = null;
    }

    leftIcon = this._cloneIcon(icon || leftIcon, active, error, disabled, leftIconStateful, block, 'left');
    var passwordIcon = getDeprecatedIcon(passwordIconClassName, passwordIconChildren, propPasswordIcon);
    if (passwordIcon !== null && type === 'password' && !disabled) {
      rightIcon = React.createElement(PasswordButton, {
        key: 'password-btn',
        onClick: this._togglePasswordField,
        active: active,
        passwordVisible: passwordVisible,
        icon: passwordIcon,
        block: block,
        floating: !!label
      });
    } else if (inlineIndicator) {
      var el = Children.only(inlineIndicator);
      rightIcon = cloneElement(inlineIndicator, {
        key: 'icon-right',
        className: cn('md-text-field-inline-indicator', {
          'md-text-field-inline-indicator--floating': label,
          'md-text-field-inline-indicator--block': block
        }, el.props.className)
      });
    } else {
      rightIcon = this._cloneIcon(rightIcon, active, error, disabled, rightIconStateful, block, 'right');
    }
    var rightIconed = !!rightIcon && type !== 'password' && !inlineIndicator;

    var floatingLabel = React.createElement(FloatingLabel, {
      key: 'label',
      label: label,
      htmlFor: id,
      active: active,
      error: error,
      floating: floating,
      customSize: customSize,
      disabled: disabled,
      iconOffset: !!leftIcon
    });

    var message = React.createElement(TextFieldMessage, {
      key: 'message',
      active: active,
      error: error,
      errorText: errorText,
      helpText: helpText,
      helpOnFocus: helpOnFocus,
      block: block,
      maxLength: maxLength,
      leftIcon: !!leftIcon,
      rightIcon: !!rightIcon,
      currentLength: currentLength
    });

    var field = React.createElement(InputField, _extends({}, props, {
      required: required,
      key: 'field',
      ref: this._setField,
      id: id,
      type: type,
      label: label,
      style: inputStyle,
      className: cn({ 'md-text-field--toolbar': toolbar }, inputClassName),
      disabled: disabled,
      customSize: customSize,
      fullWidth: fullWidth,
      passwordVisible: passwordVisible,
      placeholder: placeholder,
      block: block,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      onChange: this._handleChange,
      inlineIndicator: !!inlineIndicator
    }));

    var divider = void 0;
    if (!block) {
      divider = React.createElement(TextFieldDivider, {
        key: 'text-divider',
        active: active,
        error: error,
        lineDirection: lineDirection
      });
    }

    var children = void 0;
    if (leftIcon || rightIconed) {
      children = React.createElement(
        'div',
        { key: 'icon-divider', className: 'md-text-field-icon-container' },
        leftIcon,
        React.createElement(
          'div',
          {
            key: 'divider-container',
            className: cn('md-text-field-divider-container', {
              'md-text-field-divider-container--grow': fullWidth
            })
          },
          field,
          divider
        ),
        rightIcon
      );
    } else {
      children = [leftIcon, field, divider, rightIcon];
    }

    children = [floatingLabel, children, message];

    var multiline = typeof props.rows !== 'undefined';
    return React.createElement(
      'div',
      {
        style: styles,
        className: cn('md-text-field-container', {
          'md-inline-block': !fullWidth && !block,
          'md-full-width': block || fullWidth,
          'md-text-field-container--disabled': disabled,
          'md-text-field-container--input': !multiline,
          'md-text-field-container--input-block': block && !multiline,
          'md-text-field-container--multiline': multiline,
          'md-text-field-container--multiline-block': multiline && block,
          'md-text-field-container--padded-block': block && paddedBlock
        }, className),
        onClick: this._handleContainerClick,
        onDoubleClick: onDoubleClick,
        onMouseOver: onMouseOver,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        onMouseUp: onMouseUp,
        onTouchStart: onTouchStart,
        onTouchEnd: onTouchEnd,
        onTouchCancel: onTouchCancel,
        onTouchMove: onTouchMove,
        ref: this._setContainer
      },
      ink,
      children
    );
  };

  _createClass(TextField, [{
    key: 'value',


    /**
     * Gets the current value from the text field. This is used when you have an uncontrolled
     * text field and simply need the value from a ref callback.
     *
     * @return {String} the text field's value
     */
    get: function get() {
      return this.getField().value;
    }
  }]);

  return TextField;
}(PureComponent);

TextField.propTypes = {
  /**
   * The id for a text field. This is required when using the `label` prop for accessibility,
   * but normally a good idea to include one anyways.
   */
  id: isRequiredForA11y(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),

  /**
   * An optional style to apply to the text field's container.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the text field's container.
   */
  className: PropTypes.string,

  /**
   * An optional style to apply to the `input` or `textarea` tag.
   */
  inputStyle: PropTypes.object,

  /**
   * An optional className to apply to the `input` or `textarea` tag.
   */
  inputClassName: PropTypes.string,

  /**
   * An optional value to apply to the text field. This will make the component
   * controlled and require the `onChange` prop.
   */
  value: controlled(PropTypes.oneOfType([PropTypes.string, PropTypes.number]), 'onChange'),

  /**
   * An optional default value for the text field.
   */
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * Boolean if the text field should be displayed as a `block`. This is equivalent to
   * the `full width` text field in the Material Design specs. This view will disable
   * floating labels and remove the text divider from the component.
   */
  block: PropTypes.bool,

  /**
   * Boolean if the `block` text field should include padding to the left and right of
   * the text field.
   */
  paddedBlock: PropTypes.bool,

  /**
   * Boolean if the text field is currently disabled.
   */
  disabled: PropTypes.bool,

  /**
   * An optional label to display with the text field. This will convert the text field
   * into a floating label text field. You can make it single line by only using the
   * `placeholder` prop.
   */
  label: invalidIf(PropTypes.node, 'block'),

  /**
   * An optional placeholder text to display in the text field. If there is no `label` prop,
   * the text field will be displayed as a single line text field. If there is a `label` prop,
   * this will only be visible when there is no value and the user focused the text field.
   */
  placeholder: PropTypes.string,

  /**
   * The type for the text field. This is one of the most import props for mobile accessibility
   * as it will update the keyboard for the text type. This does not get applied on multiline
   * text fields.
   */
  type: PropTypes.oneOf(['text', 'number', 'email', 'search', 'tel', 'url', 'password']).isRequired,

  /**
   * An optional function to call when the text field's container triggers the `click` event.
   */
  onClick: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `doubleclick`
   * event.
   */
  onDoubleClick: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `touchstart`
   * event.
   */
  onTouchStart: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `touchmove`
   * event.
   */
  onTouchMove: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `touchcancel`
   * event.
   */
  onTouchCancel: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `touchend`
   * event.
   */
  onTouchEnd: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `mousedown`
   * event.
   */
  onMouseDown: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `mouseup`
   * event.
   */
  onMouseUp: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `mouseover`
   * event.
   */
  onMouseOver: PropTypes.func,

  /**
   * An optional function to call when the text field's container triggers the `mouseleave`
   * event.
   */
  onMouseLeave: PropTypes.func,

  /**
   * An optional onChange function to call. If the `value` prop is defined, this is
   * required.
   *
   * When the value changes in the text field, this will be called with the new text
   * field's value and the change event.
   *
   * ```js
   * onChange(e.target.value, e);
   * ```
   */
  onChange: PropTypes.func,

  /**
   * An optional function to call when the text field is blurred.
   */
  onBlur: PropTypes.func,

  /**
   * An optional function to call when the text field is focused.
   */
  onFocus: PropTypes.func,

  /**
   * An optional boolean if the `active` state of the text field can be externally
   * modified as well. The text field is usually considered active when it gains focus.
   *
   * If this prop is set, it will check both the active prop and the active state to
   * determine if one is true.
   */
  active: PropTypes.bool,

  /**
   * An optional boolean if the `error` state of the text field can be externally
   * modified as well. The text field is usually considered errored when it is required
   * and there is no value or the current length of the text field's value is greater
   * than the `maxLength` prop.
   *
   * If this prop is set, it will check both the error prop and the error state to
   * determine if one is true.
   */
  error: PropTypes.bool,

  /**
   * An optional boolean if the `floating` state of the text field's floating label can be
   * externally modified as well. The floating state is true when the text field gains focus
   * or there is a value in the text field.
   *
   * If this prop is set, it will check both the floating prop and the floating state to
   * determine if one is true.
   */
  floating: PropTypes.bool,

  /**
   * Boolean if the text field is required. If the user blurs the text field while there is
   * no value and it is required, the `error` state will be set to true.
   */
  required: PropTypes.bool,

  /**
   * The direction that the underline should appear from.
   */
  lineDirection: PropTypes.oneOf(['left', 'center', 'right']).isRequired,

  /**
   * An optional icon to place to the left of the text field.
   */
  leftIcon: PropTypes.element,

  /**
   * Boolean if the left icon should be stateful. This means that the icon will
   * gain the active or error colors with the text field.
   */
  leftIconStateful: PropTypes.bool,

  /**
   * An optional icon to place to the right of the text field.
   */
  rightIcon: PropTypes.element,

  /**
   * Boolean if the right icon should be stateful. This means that the icon will
   * gain the active or error colors with the text field.
   */
  rightIconStateful: PropTypes.bool,

  /**
   * The icon to use for a password text field.
   */
  passwordIcon: PropTypes.element,

  /**
   * Boolean if the password is initially visible.
   */
  passwordInitiallyVisible: PropTypes.bool,

  /**
   * Boolean if the text field should be displayed as full width.
   */
  fullWidth: PropTypes.bool,

  /**
   * The number of rows for the `multiline` text field. This value must be greater than
   * or equal to 1. When this value is set, the text field will be converted to a multiline
   * field.
   */
  rows: minNumber(1, false),

  /**
   * The maximum number of rows for a `multiline` text field. If this value is
   * `undefined`, `0`, or a number less than `0`, the multiline text field will
   * infinitely expand.
   */
  maxRows: PropTypes.number,

  /**
   * An optional custom size to apply to the text field. This is used along with
   * the `$md-text-field-custom-sizes` variable. It basically applies a className of
   * `md-text-field--NAME`.
   */
  customSize: PropTypes.string,

  /**
   * An optional error text to display below the text field. This will only appear when
   * the text field has the `error` state through the `error` prop, the current length
   * of the text field's value is greater than the `maxLength` prop, or the field is
   * required and the user blurs the text field with no value.
   */
  errorText: PropTypes.node,

  /**
   * An optional help text to display below the text field. This will always be visible
   * unless the `helpOnFocus` prop is set to true. Otherwise it will appear on focus.
   */
  helpText: PropTypes.node,

  /**
   * Boolean if the help text should display on focus only.
   */
  helpOnFocus: PropTypes.bool,

  /**
   * An optional max length for the text field. This will insert a counter underneath the
   * text field that appears on focus.
   */
  maxLength: PropTypes.number,

  /**
   * The ink when there is an injectInk above the text field. Used from the SelectField.
   *
   * @access private
   */
  ink: PropTypes.node,

  /**
   * An optional element to display inside of the `TextField` to the farthest right. This will
   * position the indicator absolutely and add some additional padding to the `TextField`.
   */
  inlineIndicator: PropTypes.element,

  /**
   * This prop allows the text field to resize its width to stay between the min and max sizes provided. By
   * default, the field will expand and collapse based on the amount of text provided. The collapsing can
   * be disabled by providing `disableShrink` to the configuration object.
   *
   * If the `min` prop is not provided, it will default to `180` which is about the same size as a default
   * text field.
   */
  resize: PropTypes.shape({
    min: PropTypes.number,
    max: PropTypes.number.isRequired,
    disableShrink: PropTypes.bool
  }),

  /**
   * Boolean if the TextField is in a toolbar and acting as a title. This will apply additional styles to the
   * text field to make it look like the toolbar's title.
   */
  toolbar: PropTypes.bool,

  passwordIconChildren: deprecated(PropTypes.node, 'Use the `passwordIcon` prop instead'),
  passwordIconClassName: deprecated(PropTypes.string, 'Use the `passwordIcon` prop instead'),
  icon: deprecated(PropTypes.node, 'Use the `leftIcon` or `rightIcon` prop instead'),
  floatingLabel: deprecated(PropTypes.bool, 'The `label` prop is now always floating. To create a non-floating text field, only use the `placeholder` prop'),
  adjustMinWidth: deprecated(PropTypes.bool, 'Manually add a min width style instead')
};
TextField.defaultProps = {
  type: 'text',
  lineDirection: 'left',
  passwordIcon: React.createElement(
    FontIcon,
    null,
    'remove_red_eye'
  ),
  leftIconStateful: true,
  rightIconStateful: true,
  fullWidth: true
};

var _initialiseProps = function _initialiseProps() {
  var _this4 = this;

  this.getField = function () {
    return _this4._field.getField();
  };

  this.focus = function () {
    _this4._field.focus();
  };

  this._getLength = function (v) {
    if (isValued(v)) {
      return String(v).length;
    }

    return 0;
  };

  this._setContainer = function (div) {
    _this4._container = div;
  };

  this._setField = function (field) {
    if (field !== null) {
      _this4._field = field;
    }
  };

  this._calcIconWidth = function (icon) {
    var style = window.getComputedStyle(icon);

    return icon.getBoundingClientRect().width + parseInt(style.marginLeft, 10);
  };

  this._calcWidth = function (value) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this4.props;

    var text = value;
    // if it is a password, use the bullet unicode instead
    if (props.type === 'password') {
      text = Array.from(Array(value.length)).reduce(function (s) {
        return s + '\u2022';
      }, '');
    }

    var field = _this4._field && _this4._field.getField();
    if (!isValued(text) && field) {
      text = field.value;
    }

    var min = getField(props.resize, { min: DEFAULT_TEXT_FIELD_SIZE }, 'min');
    var width = getTextWidth(text, field);
    if (width === null || !field) {
      // some error happened, don't do other logic
      return width || min;
    }

    var max = props.resize.max;


    if (_this4._container) {
      var indicator = _this4._container.querySelector('.md-text-field-inline-indicator');
      if (indicator) {
        width += indicator.getBoundingClientRect().width;
      }

      var iconContainer = _this4._container.querySelector('.md-text-field-icon-container');
      if (iconContainer) {
        // There is conditionally an icon before and after the text field, or only an icon before/after
        var _iconContainer$childr = iconContainer.children,
            first = _iconContainer$childr[0],
            second = _iconContainer$childr[1],
            third = _iconContainer$childr[2];

        if (first.classList.contains('md-icon')) {
          width += first.getBoundingClientRect().width;
          width += parseInt(window.getComputedStyle(second).marginLeft, 10);

          if (third) {
            width += _this4._calcIconWidth(third);
          }
        } else if (second) {
          width += _this4._calcIconWidth(second);
        }
      }
    }

    return Math.ceil(Math.min(max, Math.max(min, width)));
  };

  this._isErrored = function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this4.props,
        value = _ref.value,
        maxLength = _ref.maxLength,
        required = _ref.required;

    var error = _this4.state.error;

    var currentLength = _this4._getLength(value);
    if (required && error) {
      error = !isValued(value);
    }

    if (maxLength) {
      error = error || currentLength > maxLength;
    }

    return error;
  };

  this._handleContainerClick = function (e) {
    if (_this4.props.onClick) {
      _this4.props.onClick(e);
    }

    if (!_this4.props.disabled) {
      _this4.focus();
    }
  };

  this._handleBlur = function (e) {
    _this4._focus = false;
    var _props5 = _this4.props,
        required = _props5.required,
        maxLength = _props5.maxLength,
        onBlur = _props5.onBlur;

    if (onBlur) {
      onBlur(e);
    }

    var value = e.target.value;

    var state = {
      active: false,
      error: required && !isValued(value) || maxLength && String(value).length > maxLength
    };

    if (!_this4.props.block) {
      state.floating = isValued(value);
    }

    _this4.setState(state);
  };

  this._handleFocus = function (e) {
    _this4._focus = true;
    var _props6 = _this4.props,
        onFocus = _props6.onFocus,
        block = _props6.block;

    if (onFocus) {
      onFocus(e);
    }

    var state = { active: true };
    if (!block) {
      state.floating = true;
    }

    _this4.setState(state);
  };

  this._handleChange = function (e) {
    var _props7 = _this4.props,
        onChange = _props7.onChange,
        maxLength = _props7.maxLength,
        required = _props7.required,
        resize = _props7.resize;
    var value = e.target.value;

    if (onChange) {
      onChange(e.target.value, e);
    }

    var currentLength = value.length;
    var state = void 0;
    if (typeof maxLength !== 'undefined') {
      state = { currentLength: currentLength, error: currentLength > maxLength };
    } else if (required && _this4.state.error) {
      state = { error: !currentLength };
    }

    if (typeof _this4.props.value === 'undefined' && resize) {
      var width = _this4._calcWidth(value);
      if (!resize.disableShrink || !_this4.state.styles || width > _this4.state.styles.width) {
        state = state || {};
        state.styles = _extends({}, _this4.state.styles, { width: width });
      }
    }

    if (state) {
      _this4.setState(state);
    }
  };

  this._togglePasswordField = function () {
    _this4.setState({ passwordVisible: !_this4.state.passwordVisible }, _this4.focus);
  };
};

export default TextField;