var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent, Children } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import deprecated from 'react-prop-types/lib/deprecated';

import controlled from '../utils/PropTypes/controlled';
import getField from '../utils/getField';
import contextTypes from './contextTypes';
import getDeprecatedIcon from '../FontIcons/getDeprecatedIcon';
import FontIcon from '../FontIcons/FontIcon';
import Paper from '../Papers/Paper';
import Collapse from '../Helpers/Collapse';

var Card = function (_PureComponent) {
  _inherits(Card, _PureComponent);

  function Card(props) {
    _classCallCheck(this, Card);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._handleMouseOver = function (e) {
      if (_this.props.onMouseOver) {
        _this.props.onMouseOver(e);
      }

      if (_this.props.raise && !_this._touched) {
        _this.setState({ zDepth: 4 });
      }
    };

    _this._handleMouseLeave = function (e) {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave(e);
      }

      _this._touched = false;
      if (_this.props.raise && _this.state.zDepth !== 1) {
        _this.setState({ zDepth: 1 });
      }
    };

    _this._handleTouchStart = function (e) {
      if (_this.props.onTouchStart) {
        _this.props.onTouchStart(e);
      }

      _this._touched = true;
    };

    _this._handleExpandClick = function (e) {
      var onExpanderClick = _this.props.onExpanderClick;

      var expanded = !getField(_this.props, _this.state, 'expanded');
      if (onExpanderClick) {
        onExpanderClick(expanded, e);
      }

      if (typeof _this.props.expanded === 'undefined') {
        _this.setState({ expanded: expanded });
      }
    };

    _this.state = {
      zDepth: 1,
      expanded: typeof props.initiallyExpanded !== 'undefined' ? props.initiallyExpanded : !!props.defaultExpanded
    };
    return _this;
  }

  Card.prototype.getChildContext = function getChildContext() {
    var _props = this.props,
        expanderTooltipLabel = _props.expanderTooltipLabel,
        expanderTooltipDelay = _props.expanderTooltipDelay,
        expanderTooltipPosition = _props.expanderTooltipPosition,
        expanderIcon = _props.expanderIcon,
        iconClassName = _props.iconClassName,
        iconChildren = _props.iconChildren,
        expanderIconClassName = _props.expanderIconClassName,
        expanderIconChildren = _props.expanderIconChildren;


    var expanded = typeof this.props.isExpanded !== 'undefined' ? this.props.isExpanded : getField(this.props, this.state, 'expanded');

    return {
      expanded: expanded,
      onExpandClick: this._handleExpandClick,
      icon: getDeprecatedIcon(iconChildren || expanderIconChildren, iconClassName || expanderIconClassName, expanderIcon),
      tooltipLabel: expanderTooltipLabel,
      tooltipDelay: expanderTooltipDelay,
      tooltipPosition: expanderTooltipPosition
    };
  };

  Card.prototype.render = function render() {
    var zDepth = this.state.zDepth;

    var _props2 = this.props,
        className = _props2.className,
        raise = _props2.raise,
        tableCard = _props2.tableCard,
        children = _props2.children,
        animate = _props2.animate,
        propExpanded = _props2.expanded,
        onExpanderClick = _props2.onExpanderClick,
        defaultExpanded = _props2.defaultExpanded,
        expanderIcon = _props2.expanderIcon,
        expanderIconChildren = _props2.expanderIconChildren,
        expanderIconClassName = _props2.expanderIconClassName,
        expanderTooltipLabel = _props2.expanderTooltipLabel,
        expanderTooltipDelay = _props2.expanderTooltipDelay,
        expanderTooltipPosition = _props2.expanderTooltipPosition,
        iconChildren = _props2.iconChildren,
        iconClassName = _props2.iconClassName,
        isExpanded = _props2.isExpanded,
        initiallyExpanded = _props2.initiallyExpanded,
        props = _objectWithoutProperties(_props2, ['className', 'raise', 'tableCard', 'children', 'animate', 'expanded', 'onExpanderClick', 'defaultExpanded', 'expanderIcon', 'expanderIconChildren', 'expanderIconClassName', 'expanderTooltipLabel', 'expanderTooltipDelay', 'expanderTooltipPosition', 'iconChildren', 'iconClassName', 'isExpanded', 'initiallyExpanded']);

    var expanded = typeof this.props.isExpanded !== 'undefined' ? this.props.isExpanded : getField(this.props, this.state, 'expanded');
    var expanderIndex = -1;
    var parts = Children.map(Children.toArray(children), function (child, i) {
      if (!child || !child.props) {
        return child;
      } else if (expanderIndex < 0 && (child.props.isExpander || child.props.expander)) {
        expanderIndex = i;
      }

      if (!child.props.expandable) {
        return child;
      }

      var collapsed = expanderIndex === -1 || expanderIndex === i || !expanded;
      return React.createElement(
        Collapse,
        { collapsed: collapsed, animate: animate },
        child
      );
    });

    return React.createElement(
      Paper,
      _extends({}, props, {
        zDepth: zDepth,
        className: cn('md-card', {
          'md-card--raise': raise,
          'md-card--table': tableCard
        }, 'md-background--card', className),
        onMouseOver: this._handleMouseOver,
        onMouseLeave: this._handleMouseLeave,
        onTouchStart: this._handleTouchStart
      }),
      parts
    );
  };

  return Card;
}(PureComponent);

Card.propTypes = {
  /**
   * An optional style to apply.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the card.
   */
  className: PropTypes.string,

  /**
   * Any Card parts that should be rendered.
   */
  children: PropTypes.node,

  /**
   * Boolean if the card is expanded by default when there is an expander
   * component.
   */
  defaultExpanded: PropTypes.bool,

  /**
   * Boolean if the card should raise on hover when on a desktop display.
   */
  raise: PropTypes.bool,

  /**
   * Boolean if the card is currently expanded. This will require the `onExpanderClick` function
   * to toggle the state. The card will become controlled if this is not `undefined`.
   */
  expanded: controlled(PropTypes.bool, 'onExpanderClick', 'defaultExpanded'),

  /**
   * An optional function to call when the expander is clicked.
   */
  onExpanderClick: PropTypes.func,

  /**
   * The icon to use for the expander button. It is recommended to use this prop over
   * the `expaderIconChildren` and `expanderIconClassName` since it provides more control.
   */
  expanderIcon: PropTypes.element,

  /**
   * The tooltip position for the expander icon.
   */
  expanderTooltipPosition: PropTypes.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * The optional tooltip to display for the expander icon.
   */
  expanderTooltipLabel: PropTypes.node,

  /**
   * An optional delay before the tooltip appears for the expander icon on hover.
   */
  expanderTooltipDelay: PropTypes.number,

  /**
   * Boolean if the card contains a table. It will update the styling accordingly.
   * When using the `DataTable` component, do not wrap it in a `CardText` component.
   *
   * ```js
   * <Card tableCard={true}>
   *   <CardTitle title="Example />
   *   <DataTable>
   *     ...
   *   </DataTable>
   * </Card>
   * ```
   */
  tableCard: PropTypes.bool,

  /**
   * An optional function to call when the mouseover event is triggered.
   */
  onMouseOver: PropTypes.func,

  /**
   * An optional function to call when the mouseleave event is triggered.
   */
  onMouseLeave: PropTypes.func,

  /**
   * An optional function to call when the touchstart event is triggered.
   */
  onTouchStart: PropTypes.func,

  /**
   * Boolean if the card expansion should be animated.
   */
  animate: PropTypes.bool,

  expanderIconClassName: deprecated(PropTypes.string, 'Use `expanderIcon` instead'),
  expanderIconChildren: deprecated(PropTypes.node, 'Use `expanderIcon` instead'),
  initiallyExpanded: deprecated(PropTypes.bool, 'Use `defaultExpanded` instead'),
  isExpanded: deprecated(PropTypes.bool, 'Use `expanded` instead'),
  iconChildren: deprecated(PropTypes.node, 'Use the `expanderIconChildren` prop instead'),
  iconClassName: deprecated(PropTypes.string, 'Use the `expanderIconClassName` prop instead')
};
Card.defaultProps = {
  animate: true,
  expanderIcon: React.createElement(
    FontIcon,
    null,
    'keyboard_arrow_down'
  ),
  expanderTooltipPosition: 'left'
};
Card.childContextTypes = contextTypes;
export default Card;