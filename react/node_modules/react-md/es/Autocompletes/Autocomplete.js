var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { findDOMNode } from 'react-dom';
import CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';
import cn from 'classnames';

import getField from '../utils/getField';
import omit from '../utils/omit';
import findIgnoreCase from '../utils/findIgnoreCase';
import fuzzyFilter from '../utils/fuzzyFilter';
import caseInsensitiveFilter from '../utils/caseInsensitiveFilter';
import getTextWidth from '../utils/Positioning/getTextWidth';
import oneRequiredForA11y from '../utils/PropTypes/oneRequiredForA11y';
import controlled from '../utils/PropTypes/controlled';
import invalidIf from '../utils/PropTypes/invalidIf';
import { UP, DOWN, TAB } from '../constants/keyCodes';
import anchorShape from '../Helpers/anchorShape';
import fixedToShape from '../Helpers/fixedToShape';
import positionShape from '../Helpers/positionShape';

import ListItem from '../Lists/ListItem';
import Menu from '../Menus/Menu';
import TextField from '../TextFields/TextField';

/**
 * The `Autocomplete` component is useful for presenting real-time suggestions, completions,
 * or filtering.
 */

var Autocomplete = function (_PureComponent) {
  _inherits(Autocomplete, _PureComponent);

  function Autocomplete(props) {
    _classCallCheck(this, Autocomplete);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _initialiseProps.call(_this);

    var defaultValue = props.defaultValue,
        data = props.data,
        dataLabel = props.dataLabel,
        filter = props.filter,
        showUnfilteredData = props.showUnfilteredData;


    var matches = [];
    if (defaultValue && filter) {
      matches = filter(data, defaultValue, dataLabel);
    } else if (!filter || showUnfilteredData) {
      matches = data;
    }

    _this.state = {
      value: defaultValue,
      matches: matches,
      visible: false,
      matchIndex: -1,
      manualFocus: false,
      suggestion: '',
      suggestionIndex: -1
    };
    return _this;
  }

  Autocomplete.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var nextValue = nextProps.value,
        data = nextProps.data,
        filter = nextProps.filter,
        dataLabel = nextProps.dataLabel;

    var dataDiff = data !== this.props.data;
    if (nextValue !== this.props.value || dataDiff) {
      var _state = this.state,
          visible = _state.visible,
          matches = _state.matches;

      var value = getField(nextProps, this.state, 'value');

      if (filter) {
        matches = filter(data, value, dataLabel);
      } else if (dataDiff) {
        matches = data;
      }

      if (this.state.focus) {
        visible = !!matches.length;
      }

      this.setState({ matches: matches, visible: visible });
    }
  };

  Autocomplete.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    if (this.state.visible !== nextState.visible) {
      var menuFn = nextProps['onMenu' + (nextState.visible ? 'Open' : 'Close')];
      if (menuFn) {
        menuFn();
      }
    }
  };

  /**
   * Gets the current value from the text field. This is used when you have an uncontrolled
   * text field and simply need the value from a ref callback.
   *
   * @return {String} the text field's value
   */


  Autocomplete.prototype.render = function render() {
    var _state2 = this.state,
        visible = _state2.visible,
        matches = _state2.matches,
        tabbed = _state2.tabbed,
        focus = _state2.focus,
        suggestionStyle = _state2.suggestionStyle;

    var _props = this.props,
        fullWidth = _props.fullWidth,
        block = _props.block,
        style = _props.style,
        className = _props.className,
        listStyle = _props.listStyle,
        listClassName = _props.listClassName,
        textFieldStyle = _props.textFieldStyle,
        textFieldClassName = _props.textFieldClassName,
        inlineSuggestionStyle = _props.inlineSuggestionStyle,
        inlineSuggestionClassName = _props.inlineSuggestionClassName,
        menuId = _props.menuId,
        inline = _props.inline,
        anchor = _props.anchor,
        belowAnchor = _props.belowAnchor,
        position = _props.position,
        fixedTo = _props.fixedTo,
        listId = _props.listId,
        listInline = _props.listInline,
        listZDepth = _props.listZDepth,
        listHeightRestricted = _props.listHeightRestricted,
        xThreshold = _props.xThreshold,
        yThreshold = _props.yThreshold,
        closeOnOutsideClick = _props.closeOnOutsideClick,
        transitionName = _props.transitionName,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        centered = _props.centered,
        sameWidth = _props.sameWidth,
        repositionOnScroll = _props.repositionOnScroll,
        repositionOnResize = _props.repositionOnResize,
        simplifiedMenu = _props.simplifiedMenu,
        minLeft = _props.minLeft,
        minRight = _props.minRight,
        minBottom = _props.minBottom,
        fillViewportWidth = _props.fillViewportWidth,
        fillViewportHeight = _props.fillViewportHeight,
        propValue = _props.value,
        total = _props.total,
        offset = _props.offset,
        filter = _props.filter,
        data = _props.data,
        dataLabel = _props.dataLabel,
        dataValue = _props.dataValue,
        deleteKeys = _props.deleteKeys,
        defaultValue = _props.defaultValue,
        clearOnAutocomplete = _props.clearOnAutocomplete,
        autocompleteWithLabel = _props.autocompleteWithLabel,
        findInlineSuggestion = _props.findInlineSuggestion,
        inlineSuggestionPadding = _props.inlineSuggestionPadding,
        onAutocomplete = _props.onAutocomplete,
        onMenuOpen = _props.onMenuOpen,
        onMenuClose = _props.onMenuClose,
        onBlur = _props.onBlur,
        onFocus = _props.onFocus,
        onKeyDown = _props.onKeyDown,
        onMouseDown = _props.onMouseDown,
        onChange = _props.onChange,
        showUnfilteredData = _props.showUnfilteredData,
        props = _objectWithoutProperties(_props, ['fullWidth', 'block', 'style', 'className', 'listStyle', 'listClassName', 'textFieldStyle', 'textFieldClassName', 'inlineSuggestionStyle', 'inlineSuggestionClassName', 'menuId', 'inline', 'anchor', 'belowAnchor', 'position', 'fixedTo', 'listId', 'listInline', 'listZDepth', 'listHeightRestricted', 'xThreshold', 'yThreshold', 'closeOnOutsideClick', 'transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'centered', 'sameWidth', 'repositionOnScroll', 'repositionOnResize', 'simplifiedMenu', 'minLeft', 'minRight', 'minBottom', 'fillViewportWidth', 'fillViewportHeight', 'value', 'total', 'offset', 'filter', 'data', 'dataLabel', 'dataValue', 'deleteKeys', 'defaultValue', 'clearOnAutocomplete', 'autocompleteWithLabel', 'findInlineSuggestion', 'inlineSuggestionPadding', 'onAutocomplete', 'onMenuOpen', 'onMenuClose', 'onBlur', 'onFocus', 'onKeyDown', 'onMouseDown', 'onChange', 'showUnfilteredData']);

    delete props.focusInputOnAutocomplete;

    var value = getField(this.props, this.state, 'value');

    var autocomplete = React.createElement(TextField, _extends({}, props, {
      'aria-autocomplete': inline ? 'inline' : 'list',
      style: textFieldStyle,
      className: cn('md-autocomplete', textFieldClassName),
      key: 'autocomplete',
      ref: this._setField,
      value: value,
      onKeyDown: this._handleTextFieldKeyDown,
      onMouseDown: this._toggleMenu,
      onChange: this._handleChange,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      fullWidth: fullWidth,
      block: block
    }));

    if (inline) {
      var suggestion = void 0;
      if (focus && this.state.suggestion) {
        suggestion = React.createElement(
          'span',
          {
            key: 'suggestion',
            style: _extends({}, suggestionStyle, inlineSuggestionStyle),
            className: cn('md-autocomplete-suggestion', {
              'md-autocomplete-suggestion--floating': props.label,
              'md-autocomplete-suggestion--block': block
            }, inlineSuggestionClassName)
          },
          this.state.suggestion
        );
      }

      return React.createElement(
        CSSTransitionGroup,
        {
          component: 'div',
          style: style,
          className: cn('md-menu-container md-autocomplete-container', className, {
            'md-full-width': fullWidth || block
          }),
          transitionName: 'opacity',
          transitionEnterTimeout: 150,
          transitionLeave: !tabbed,
          transitionLeaveTimeout: 150,
          onTouchStart: this._handleTouchStart
        },
        autocomplete,
        suggestion
      );
    }

    return React.createElement(
      Menu,
      {
        id: menuId || props.id + '-menu',
        listId: listId,
        ref: this._setMenu,
        toggle: autocomplete,
        visible: visible,
        onClick: this._handleClick,
        onClose: this._close,
        onKeyDown: this._handleMenuKeyDown,
        simplified: simplifiedMenu,
        sameWidth: sameWidth,
        centered: centered,
        anchor: anchor,
        belowAnchor: belowAnchor,
        position: position,
        fixedTo: fixedTo,
        listInline: listInline,
        listZDepth: listZDepth,
        listHeightRestricted: listHeightRestricted,
        xThreshold: xThreshold,
        yThreshold: yThreshold,
        closeOnOutsideClick: closeOnOutsideClick,
        transitionName: transitionName,
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout,
        fullWidth: fullWidth || block,
        style: style,
        className: cn('md-autocomplete-container', className),
        listStyle: listStyle,
        listClassName: cn('md-autocomplete-list', listClassName),
        repositionOnScroll: repositionOnScroll,
        repositionOnResize: repositionOnResize,
        minLeft: minLeft,
        minRight: minRight,
        minBottom: minBottom,
        fillViewportWidth: fillViewportWidth,
        fillViewportHeight: fillViewportHeight
      },
      matches.map(this._mapToListItem)
    );
  };

  _createClass(Autocomplete, [{
    key: 'value',
    get: function get() {
      return getField(this.props, this.state, 'value');
    }

    /**
     * Just check if the click target is in a list item.. if it is, autocomplete the text field
     * with that item.
     */


    /**
     * The `mousedown` event is used instead of `click` because of the order
     * of the `mousedown`, `focus`, and `click` events.
     */


    /**
     * Allows touch devices to autocomplete the inline view by tapping:
     * - the suggestion text
     * - the text field IF there is a suggestion visible
     */

  }]);

  return Autocomplete;
}(PureComponent);

Autocomplete.HorizontalAnchors = Menu.HorizontalAnchors;
Autocomplete.VerticalAnchors = Menu.VerticalAnchors;
Autocomplete.Positions = Menu.Positions;
Autocomplete.fuzzyFilter = fuzzyFilter;
Autocomplete.caseInsensitiveFilter = caseInsensitiveFilter;
Autocomplete.findIgnoreCase = findIgnoreCase;
Autocomplete.propTypes = {
  /**
   * An id to give the autocomplete. Either this or the `menuId` is required for accessibility.
   *
   * @see {@link #menuId}
   */
  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * The menu id to provide to the autocomplete. Either this prop or the `id` prop is required. If
   * this props is omitted, the menuId will become: `${id}-menu`
   */
  menuId: oneRequiredForA11y(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'id'),

  /**
   * An optional id to provide to the menu's list.
   *
   * @see {@link Menus/Menu#listId}
   */
  listId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * An optional style to apply to the menu that contains the autocomplete.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the menu that contains the autocomplete.
   */
  className: PropTypes.string,

  /**
   * An optional style to apply to the autocomplete's text field.
   */
  textFieldStyle: PropTypes.object,

  /**
   * An optional className to apply to the autocomplete's text field.
   */
  textFieldClassName: PropTypes.string,

  /**
   * An optional style to apply to the autocomplete's text field input itself.
   */
  inputStyle: PropTypes.object,

  /**
   * An optional className to apply to the autocomplete's input field itself.
   */
  inputClassName: PropTypes.string,

  /**
   * The optional style to apply to the opened menu List if the
   * `Autocomplete` is not using `inline` suggestions.
   */
  listStyle: PropTypes.object,

  /**
   * The optional className to apply to the opened menu List if the
   * `Autocomplete` is not using `inline` suggestions.
   */
  listClassName: PropTypes.string,

  /**
   * An optional style to apply to the inline suggestion when using `inline` mode.
   */
  inlineSuggestionStyle: PropTypes.object,

  /**
   * An optional className to apply to the inline suggestion when using `inline` mode.
   */
  inlineSuggestionClassName: PropTypes.string,

  /**
   * Boolean if the autocomplete is disabled.
   */
  disabled: PropTypes.bool,

  /**
   * A label to display with the autocomplete.
   */
  label: PropTypes.node,

  /**
   * An optional value to use for the text field. This will force this component
   * to be controlled and require the `onChange` function.
   */
  value: controlled(PropTypes.oneOfType([PropTypes.string, PropTypes.number]), 'onChange'),

  /**
   * The default value for the autocomplete's text field.
   */
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * An object key to use to extract the text to be compared for filtering.
   * This will only be applied if the given `data` prop is an array of objects.
   */
  dataLabel: PropTypes.string.isRequired,

  /**
   * An optional object key to use to extract the `value` of the given `data` prop.
   * This is really only used with generating a unique react key. The unique react
   * key with either be:
   * - the datum if it is a string or number
   * - the `key` attribute of the datum object
   * - the `datum[dataValue]`
   * - or the `datum[dataLabel]`
   */
  dataValue: PropTypes.string,

  /**
   * A single key or an array of keys to delete from your data object before passing
   * to the `ListItem` component.
   */
  deleteKeys: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),

  /**
   * The data that will be used for autocomplete suggestions. This can either be
   * an array of string, number, or object. If it is an array of objects, the key
   * `dataLabel` is required.
   *
   * ```docgen
   * PropTypes.arrayOf(PropTypes.oneOfType([
   *   PropTypes.element,
   *   PropTypes.string,
   *   PropTypes.number,
   *   PropTypes.shape({
   *     [dataLabel]: PropTypes.oneOfType([
   *       PropTypes.string,
   *       PropTypes.number,
   *       PropTypes.node,
   *     ]).isRequired,
   *   }),
   * ])).isRequired
   * ```
   */
  data: function data(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    var _PropTypes$arrayOf, _PropTypes$shape;

    var dataLabel = props.dataLabel;

    return (_PropTypes$arrayOf = PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.string, PropTypes.number, PropTypes.shape((_PropTypes$shape = {}, _PropTypes$shape[dataLabel] = PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.node]).isRequired, _PropTypes$shape))]))).isRequired.apply(_PropTypes$arrayOf, [props, propName, component].concat(others));
  },

  /**
   * An optional number representing the total number of results in the `data` prop.
   * This should really only be used when the data is paginated. When this is set,
   * each item in the suggestion menu will be updated with the `aria-setsize` and
   * `aria-posinset`.
   *
   * @see {@link #offset}
   */
  total: invalidIf(PropTypes.number, 'inline'),

  /**
   * An optional number representing the data's offset if the results were paginated.
   * This is used for accessibility with the `aria-posinset` attribute.
   *
   * @see {@link #total}
   */
  offset: PropTypes.number.isRequired,

  /**
   * An optional function to use to filter the `data`. If you have a sexy backend
   * using solr or some other search/indexer, it is recommended to set this prop to
   * `null`.
   */
  filter: PropTypes.func,

  /**
   * An optional function to call when the `Autocomplete`'s text field has a `keydown` event.
   */
  onKeyDown: PropTypes.func,

  /**
   * An optional function to call when the `Autocomplete`'s text field has a `mousedown` event.
   */
  onMouseDown: PropTypes.func,

  /**
   * An optional function to call when the `Autocomplete`'s text field value changes.
   * The callback will be given the new value and the change event.
   *
   * `onChange(textFeldValue, event)`
   */
  onChange: PropTypes.func,

  /**
   * An optional function to call when the `Autocomplete`'s text field is focused.
   */
  onFocus: PropTypes.func,

  /**
   * An optional function to call when the entire `Autocomplete` component is blurred.
   * This will be triggered when the window is clicked or when a user tabs away from
   * the autocomplete.
   */
  onBlur: PropTypes.func,

  /**
   * Boolean if this text field should be styled as a full width text field.
   * Floating labels and the text field indicator will be removed automatically.
   */
  block: PropTypes.bool,

  /**
   * Boolean if the autocomplete should span the entire width.
   */
  fullWidth: PropTypes.bool,

  /**
   * Boolean if the `Autocomplete` should display suggestions inline instead
   * of in a `Menu`.
   */
  inline: PropTypes.bool,

  /**
   * The amount of padding to use between the current text and the inline suggestion text.
   */
  inlineSuggestionPadding: PropTypes.number.isRequired,

  /**
   * The function to call to find a suggestion for an inline autocomplete. This function
   * expects to return a single result of a number or a string.
   *
   * ```js
   * @param {Array<Object|String|Number>} data - The data prop to search.
   * @param {String} value - The current value to use for searching.
   * @param {String} dataLabel - The `dataLabel` prop to use if a datum is an object.
   * @return {String|Number} the found suggestion or false-ish
   * ```
   */
  findInlineSuggestion: PropTypes.func,

  /**
   * An optional function to call when an autocomplete suggestion is clicked either
   * by using the mouse, the enter/space key, or touch. The match index and current
   * `dataLabel` will be given back.
   *
   * `onAutocomplete(suggestion, suggestionIndex, matches);`
   *
   * @see {@link #autocompleteWithLabel}
   */
  onAutocomplete: PropTypes.func,

  /**
   * Boolean if the `onAutocomplete` should attempt send the `suggestion[dataLabel]` instead
   * of `suggestion[dataValue]` when the data is an object.
   *
   * @see {@link #onAutocomplete}
   */
  autocompleteWithLabel: PropTypes.bool,

  /**
   * A boolean if the text field's value should be reset to the empty string when
   * an item is auto-completed. This is useful if you do not want a fully controlled
   * component and the values are stored outside of the `TextField`. (like `Chips`).
   */
  clearOnAutocomplete: PropTypes.bool,

  /**
   * An optional function to call when the `Autocomplete` suggestion menu opens.
   */
  onMenuOpen: PropTypes.func,

  /**
   * An optional function to call when the `Autocomplete` suggestion menu closes.
   */
  onMenuClose: PropTypes.func,

  /**
   * This prop is used for disabling the browser's default autocomplete suggestions
   * of previously typed values in the text field. By default, this is disabled.
   */
  autoComplete: PropTypes.oneOf(['on', 'off']),

  /**
   * Boolean if the `input` should be focused again after a suggestion was clicked.
   *
   * This is really only added for keyboard support and the fact that each of suggestions
   * are focusable.
   */
  focusInputOnAutocomplete: PropTypes.bool,

  /**
   * This is how the menu's `List` gets anchored to the `toggle` element.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  anchor: anchorShape,

  /**
   * This is the anchor to use when the `position` is set to `Autocomplete.Positions.BELOW`.
   *
   * @see {@link Helpers/Layover#belowAnchor}
   */
  belowAnchor: anchorShape,

  /**
   * This is the animation position for the list that appears.
   *
   * @see {@link Helpers/Layover#animationPosition}
   */
  position: positionShape,

  /**
   * This is how the menu's list will be "fixed" to the `toggle` component.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * Boolean if the menu's list should appear horizontally instead of vertically.
   */
  listInline: PropTypes.bool,

  /**
   * The list's z-depth for applying box shadow. This should be a number from 0 to 5.
   */
  listZDepth: PropTypes.number,

  /**
   * Boolean if the list should have its height restricted to the `$md-menu-mobile-max-height`/
   * `$md-menu-desktop-max-height` values.
   *
   * @see [md-menu-mobile-max-height](/components/menus?tab=2#variable-md-menu-mobile-max-height)
   * @see [md-menu-desktop-max-height](/components/menus?tab=2#variable-md-menu-desktop-max-height)
   */
  listHeightRestricted: PropTypes.bool,

  /**
   * @see {@link Helpers/Layover#xThreshold}
   */
  xThreshold: PropTypes.number,

  /**
   * @see {@link Helpers/Layover#yThreshold}
   */
  yThreshold: PropTypes.number,

  /**
   * @see {@link Helpers/Layover#closeOnOutsideClick}
   */
  closeOnOutsideClick: PropTypes.bool,

  /**
   * An optional transition name to use for the list appearing/disappearing.
   *
   * @see {@link Helpers/Layover#transitionName}
   */
  transitionName: PropTypes.string,

  /**
   * @see {@link Helpers/Layover#transitionEnterTimeout}
   */
  transitionEnterTimeout: PropTypes.number,

  /**
   * @see {@link Helpers/Layover#transitionLeaveTimeout}
   */
  transitionLeaveTimeout: PropTypes.number,

  /**
   * @see {@link Helpers/Layover#centered}
   */
  centered: Menu.propTypes.centered,

  /**
   * @see {@link Helpers/Layover#sameWidth}
   */
  sameWidth: Menu.propTypes.sameWidth,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: PropTypes.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: PropTypes.bool,

  /**
   * Boolean if the menu logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the menu.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: PropTypes.bool,

  /**
   * @see {@link Helpers/Layover#minLeft}
   */
  minLeft: PropTypes.number,

  /**
   * @see {@link Helpers/Layover#minRight}
   */
  minRight: PropTypes.number,

  /**
   * @see {@link Helpers/Layover#minBottom}
   */
  minBottom: PropTypes.number,

  /**
   * @see {@link Helpers/Layover#fillViewportWidth}
   */
  fillViewportWidth: PropTypes.bool,

  /**
   * @see {@link Helpers/Layover#fillViewportHeight}
   */
  fillViewportHeight: PropTypes.bool,

  /**
   * @see {@link TextFields#toolbar}
   */
  toolbar: PropTypes.bool,

  /**
   * Boolean if the list of data should be shown on focus when no filter value has been
   * provided.
   */
  showUnfilteredData: PropTypes.bool
};
Autocomplete.defaultProps = {
  autocompleteWithLabel: false,
  position: Menu.Positions.BELOW,
  sameWidth: true,
  offset: 0,
  fullWidth: true,
  defaultValue: '',
  dataLabel: 'primaryText',
  filter: Autocomplete.fuzzyFilter,
  findInlineSuggestion: Autocomplete.findIgnoreCase,
  autoComplete: 'off',
  repositionOnScroll: true,
  repositionOnResize: true,
  showUnfilteredData: false,
  inlineSuggestionPadding: 6
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._close = function (e) {
    if (_this2.props.onBlur) {
      _this2.props.onBlur(e);
    }

    _this2.setState({ visible: false });
  };

  this._handleChange = function (value, event) {
    var _props2 = _this2.props,
        onChange = _props2.onChange,
        filter = _props2.filter,
        findInlineSuggestion = _props2.findInlineSuggestion,
        data = _props2.data,
        dataLabel = _props2.dataLabel,
        inline = _props2.inline,
        showUnfilteredData = _props2.showUnfilteredData;


    if (onChange) {
      onChange(value, event);
    }

    if (inline) {
      // If findInlineSuggestion does not exist, assume that `onChange` will handle it.
      return findInlineSuggestion ? _this2._findInlineSuggestions(value) : null;
    }

    var visible = _this2.state.visible;

    var hasValidValue = value || showUnfilteredData;

    var matches = hasValidValue || !filter ? data : [];
    if (value && filter) {
      matches = filter(data, value, dataLabel);
    }

    if (filter) {
      visible = !!matches.length;
    }

    return _this2.setState({ matches: matches, visible: visible, value: value });
  };

  this._handleFocus = function (e) {
    if (_this2.props.onFocus) {
      _this2.props.onFocus(e);
    }

    var value = e.target.value;

    if (_this2.props.inline && value) {
      if (_this2.props.findInlineSuggestion) {
        _this2._findInlineSuggestions(value);
      }

      return;
    }

    var hasValidValue = !!value || _this2.props.showUnfilteredData;

    _this2.setState({
      matchIndex: -1,
      visible: !_this2.state.manualFocus && hasValidValue && !!_this2.state.matches.length,
      manualFocus: false,
      focus: true
    });
  };

  this._handleBlur = function (e) {
    if (_this2.props.inline || !_this2.state.matches.length) {
      if (_this2.props.onBlur) {
        _this2.props.onBlur(e);
      }
    }

    _this2.setState({ focus: false });
  };

  this._handleInlineAutocomplete = function () {
    var _state3 = _this2.state,
        suggestionIndex = _state3.suggestionIndex,
        matches = _state3.matches;

    if (suggestionIndex === -1) {
      return;
    }

    var _props3 = _this2.props,
        data = _props3.data,
        dataLabel = _props3.dataLabel,
        dataValue = _props3.dataValue,
        label = _props3.autocompleteWithLabel,
        onAutocomplete = _props3.onAutocomplete;


    var value = data[suggestionIndex];
    if (onAutocomplete) {
      var v = value;
      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
        if (!label) {
          v = value[dataValue];
        } else {
          v = value[dataLabel];
        }
      }

      onAutocomplete(v, suggestionIndex, matches);
    }

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      value = value[dataLabel];
    }

    _this2.setState({
      value: value,
      suggestion: '',
      suggestionIndex: -1,
      tabbed: true
    });
  };

  this._handleTextFieldKeyDown = function (e) {
    var _props4 = _this2.props,
        inline = _props4.inline,
        onKeyDown = _props4.onKeyDown;
    var suggestionIndex = _this2.state.suggestionIndex;


    var key = e.which || e.keyCode;
    if (onKeyDown) {
      onKeyDown(e);
    }

    if (inline && key === TAB && suggestionIndex !== -1) {
      // Autocomplete the text field
      e.preventDefault();
      _this2._handleInlineAutocomplete();
    }
  };

  this._handleMenuKeyDown = function (e) {
    var key = e.which || e.keyCode;
    if (key === TAB) {
      if (_this2.props.onBlur) {
        _this2.props.onBlur(e);
      }

      _this2.setState({ visible: false });
    } else if (key === UP || key === DOWN) {
      _this2._focusSuggestion(key === UP, e);
    }
  };

  this._handleClick = function (e) {
    var target = e.target;
    while (_this2._menu && _this2._menu.contains(target)) {
      if (target.classList.contains('md-list-item')) {
        var items = target.parentNode.querySelectorAll('.md-list-item');
        items = Array.prototype.slice.call(items);

        return _this2._handleItemClick(items.indexOf(target));
      }

      target = target.parentNode;
    }

    return null;
  };

  this._handleItemClick = function (index) {
    if (index === -1) {
      return;
    }

    var matches = _this2.state.matches;
    var _props5 = _this2.props,
        data = _props5.data,
        dataLabel = _props5.dataLabel,
        dataValue = _props5.dataValue,
        filter = _props5.filter,
        onAutocomplete = _props5.onAutocomplete,
        clearOnAutocomplete = _props5.clearOnAutocomplete,
        focusInputOnAutocomplete = _props5.focusInputOnAutocomplete,
        label = _props5.autocompleteWithLabel;


    var value = matches.filter(function (m) {
      return !React.isValidElement(m);
    })[index];
    if (onAutocomplete) {
      var v = value;
      if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object') {
        if (!label) {
          v = value[dataValue];
        } else {
          v = value[dataLabel];
        }
      }

      onAutocomplete(v, index, matches);
    }

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      value = value[dataLabel];
    }

    value = clearOnAutocomplete ? '' : value;
    var callback = void 0;
    if (focusInputOnAutocomplete) {
      callback = function callback() {
        _this2._field.focus();
      };
    }

    _this2.setState({
      visible: false,
      manualFocus: focusInputOnAutocomplete,
      matches: filter ? filter(data, value, dataLabel) : matches,
      value: value
    }, callback);
  };

  this._focusSuggestion = function (negative, e) {
    e.preventDefault();
    var _state4 = _this2.state,
        matchIndex = _state4.matchIndex,
        matches = _state4.matches;

    var l = matches.length;

    var index = void 0;
    if (negative && matchIndex === -1 || !negative && matchIndex >= l) {
      return;
    } else if (negative) {
      index = matchIndex - 1;
      if (index === -1) {
        _this2._field.focus();
      }
    } else {
      index = Math.min(l, matchIndex + 1);
    }

    if (index !== -1 && index !== matchIndex) {
      var item = _this2._menu.querySelectorAll('.md-list-tile')[index];
      if (item) {
        item.focus();
      }
    }

    _this2.setState({ matchIndex: index });
  };

  this._findInlineSuggestions = function (value) {
    var _props6 = _this2.props,
        data = _props6.data,
        dataLabel = _props6.dataLabel,
        findInlineSuggestion = _props6.findInlineSuggestion,
        inlineSuggestionPadding = _props6.inlineSuggestionPadding;


    var suggestion = findInlineSuggestion(data, value, dataLabel);
    if ((typeof suggestion === 'undefined' ? 'undefined' : _typeof(suggestion)) === 'object') {
      throw new Error('`findInlineSuggestion` should return a string or a number, but got an object.', suggestion);
    }

    var suggestionStyle = _this2.state.suggestionStyle;

    var suggestionIndex = -1;
    if (suggestion) {
      // Find index of suggestion
      data.some(function (datum, i) {
        var d = (typeof dataum === 'undefined' ? 'undefined' : _typeof(dataum)) === 'object' ? datum[dataLabel] : datum;
        if (d === suggestion) {
          suggestionIndex = i;
        }

        return suggestionIndex !== -1;
      });

      // Strip already used letters
      suggestion = suggestion.toString().substring(value.length, suggestion.length);

      // Position the inline suggestion next to the text
      var width = getTextWidth(value, _this2._field);
      if (width !== null) {
        width += inlineSuggestionPadding;
      }

      if (width !== null && (!suggestionStyle || suggestionStyle.left !== width)) {
        suggestionStyle = { left: width };
      }
    }

    _this2.setState({
      value: value,
      suggestion: suggestion,
      suggestionIndex: suggestionIndex,
      suggestionStyle: suggestionStyle,
      tabbed: false,
      focus: true
    });
  };

  this._mapToListItem = function (match, i) {
    if (React.isValidElement(match)) {
      return match;
    }

    var _props7 = _this2.props,
        dataLabel = _props7.dataLabel,
        dataValue = _props7.dataValue,
        deleteKeys = _props7.deleteKeys,
        total = _props7.total,
        offset = _props7.offset,
        data = _props7.data;

    var props = void 0;
    switch (typeof match === 'undefined' ? 'undefined' : _typeof(match)) {
      case 'string':
      case 'number':
        props = {
          key: match,
          primaryText: match
        };
        break;
      default:
        if (deleteKeys) {
          props = omit(match, typeof deleteKeys === 'string' ? [deleteKeys] : deleteKeys);
        } else {
          props = match;
        }

        props = _extends({}, props, {
          key: match.key || dataValue && match[dataValue] || match[dataLabel],
          primaryText: match[dataLabel]
        });
    }

    if (typeof total !== 'undefined' && data.length < total) {
      props['aria-setsize'] = total;
      props['aria-posinset'] = i + 1 + offset;
    }

    // Allows focus, but does not let tab focus. This is so up and down keys work.
    return React.createElement(ListItem, _extends({ tabIndex: -1 }, props));
  };

  this._toggleMenu = function (e) {
    if (_this2.props.onMouseDown) {
      _this2.props.onMouseDown(e);
    }

    if (!_this2.props.inline && _this2.state.matches.length && getField(_this2.props, _this2.state, 'value')) {
      _this2.setState({ visible: !_this2.state.visible });
    }
  };

  this._handleTouchStart = function (e) {
    var target = e.target;
    var suggestion = _this2.state.suggestion;

    if (target.classList.contains('md-autocomplete-suggestion') && suggestion) {
      _this2._handleInlineAutocomplete();
    }
  };

  this._setField = function (field) {
    if (field) {
      _this2._field = field.getField();
    }
  };

  this._setMenu = function (menu) {
    _this2._menu = findDOMNode(menu);
  };
};

export default Autocomplete;