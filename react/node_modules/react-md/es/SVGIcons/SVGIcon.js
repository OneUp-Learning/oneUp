var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import deprecated from 'react-prop-types/lib/deprecated';

import themeColors from '../utils/themeColors';

/**
 * The `SVGIcon` component is used for rendering inline SVG icons or sprite-mapped SVGs
 * as an icon.
 */

var SVGIcon = function (_PureComponent) {
  _inherits(SVGIcon, _PureComponent);

  function SVGIcon(props) {
    _classCallCheck(this, SVGIcon);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this));

    _this._getIds = function (_ref) {
      var use = _ref.use,
          labels = _ref['aria-labelledby'],
          title = _ref.title,
          desc = _ref.desc;

      var titleId = null;
      var descId = null;
      var labelledBy = null;
      if (title || desc) {
        if (use) {
          var baseId = use.replace(/.*#/, '');
          titleId = baseId + '-title';
          descId = baseId + '-desc';

          if (title) {
            labelledBy = baseId + '-title';
          }

          if (desc) {
            labelledBy = '' + (labelledBy ? labelledBy + ' ' : '') + descId;
          }
        } else if (labels) {
          var _labels$split = labels.split(' ');

          titleId = _labels$split[0];
          descId = _labels$split[1];
        }
      }

      return { titleId: titleId, descId: descId, labelledBy: labelledBy };
    };

    _this._mergeStyles = function (_ref2) {
      var style = _ref2.style,
          size = _ref2.size;

      if (style && size) {
        return _extends({ height: size, width: size }, style);
      } else if (style) {
        return style;
      } else if (size) {
        return { height: size, width: size };
      }

      return undefined;
    };

    _this.state = _extends({
      styles: _this._mergeStyles(props)
    }, _this._getIds(props));
    return _this;
  }

  SVGIcon.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        style = _props.style,
        size = _props.size,
        use = _props.use,
        title = _props.title,
        desc = _props.desc,
        labels = _props['aria-labelledby'];

    var nextState = void 0;
    if (style !== nextProps.style || size !== nextProps.size) {
      nextState = { styles: this._mergeStyles(nextProps) };
    }

    if (title !== nextProps.title || desc !== nextProps.desc || (nextProps.title || nextProps.desc) && (use !== nextProps.use || labels !== nextProps['aria-labelledby'])) {
      nextState = _extends({}, nextState, this._getIds(nextProps));
    }

    if (nextState) {
      this.setState(nextState);
    }
  };

  SVGIcon.prototype.render = function render() {
    var _state = this.state,
        styles = _state.styles,
        titleId = _state.titleId,
        descId = _state.descId,
        labelledBy = _state.labelledBy;

    var _props2 = this.props,
        className = _props2.className,
        disabled = _props2.disabled,
        use = _props2.use,
        primary = _props2.primary,
        secondary = _props2.secondary,
        error = _props2.error,
        inherit = _props2.inherit,
        titleAttr = _props2.titleAttr,
        ariaLabelledBy = _props2['aria-labelledby'],
        size = _props2.size,
        propTitle = _props2.title,
        propDesc = _props2.desc,
        propStyle = _props2.style,
        propChildren = _props2.children,
        props = _objectWithoutProperties(_props2, ['className', 'disabled', 'use', 'primary', 'secondary', 'error', 'inherit', 'titleAttr', 'aria-labelledby', 'size', 'title', 'desc', 'style', 'children']);

    var _props3 = this.props,
        children = _props3.children,
        title = _props3.title,
        desc = _props3.desc;

    if (!children && use) {
      children = React.createElement('use', { xlinkHref: use });
    }

    if (title) {
      title = React.createElement(
        'title',
        { id: titleId },
        title
      );
    }

    if (desc) {
      desc = React.createElement(
        'desc',
        { id: descId },
        desc
      );
    }

    return React.createElement(
      'svg',
      _extends({}, props, {
        title: titleAttr,
        'aria-labelledby': ariaLabelledBy || labelledBy,
        style: styles,
        className: cn('md-icon', themeColors({
          disabled: disabled,
          error: error,
          inherit: inherit,
          primary: primary,
          secondary: secondary
        }, className))
      }),
      title,
      desc,
      children
    );
  };

  return SVGIcon;
}(PureComponent);

SVGIcon.propTypes = {
  /**
   * An optional style to apply.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply.
   */
  className: PropTypes.string,

  /**
   * Boolean if the primary theme color should be applied.
   */
  primary: PropTypes.bool,

  /**
   * Boolean if the secondary theme color should be applied.
   */
  secondary: PropTypes.bool,

  /**
   * Boolean if the icon is considered disabled and should inherit the
   * disabled color.
   */
  disabled: PropTypes.bool,

  /**
   * Boolean if the icon is considered errored and should inherit the error color.
   */
  error: PropTypes.bool,

  /**
   * Boolean if the color of the icon should be inherited by parent elements.
   */
  inherit: PropTypes.bool,

  /**
   * The role to apply to the SVG. When using icons, it is generally recommended to leave it as the default
   * `img` so that it is insured as a graphic.
   */
  role: PropTypes.oneOf(['img', 'presentation']),

  /**
   * This prop is the title attribute to provide to the `<svg>` element itself. This should be used when you
   * are using a spritesheet that has defined `<title>` with each SVG symbol.
   */
  titleAttr: PropTypes.string,

  /**
   * An optional list of ids to use to label the SVG icon with. This is helpful to add when you use the `title`
   * and `desc` props as this is used to create ids for those two props. This is super beneficial to screen readers.
   *
   * When this is defined, it is a space-delimited string of ids to provide to the title and desc (in order). If
   * this is omitted and the `use` prop is defined, it will take everything after the `#` sign and append `-title` and
   * `-desc` as a fallback. Check out the examples for more information about this.
   *
   * @see {@link #title}
   * @see {@link #desc}
   */
  'aria-labelledby': PropTypes.string,

  /**
   * An optional title to give to your SVG icon. This is generally recommended for accessibility when not using
   * the `use` prop, or your spritemap does not contain `<title>` and `<desc>.
   *
   * @see {@link #aria-labelledby}
   */
  title: PropTypes.string,

  /**
   * An optional description to give to your SVG icon. This is generally recommended for accessibility when not using
   * the `use` prop, or your spritemap does not contain `<title>` and `<desc>.
   *
   * @see {@link #aria-labelledby}
   */
  desc: PropTypes.string,

  /**
   * This should be a link to a part of an SVG spritemap. So normally one of the following:
   * - `'#some-custom-svg'`
   * - `'/images/spritemap.svg#some-custom-svg'`
   *
   * This prop **should not** be used with the `children` prop as only one will be rendered.
   *
   * > NOTE: IE **does not support** external SVGs. Please see the demo for more details.
   */
  use: PropTypes.string,

  /**
   * Any `<svg>` children to render to create your icon. This can not be used with the `use` prop.
   */
  children: PropTypes.oneOfType([PropTypes.element, PropTypes.arrayOf(PropTypes.element), PropTypes.node]),

  /**
   * Boolean if the SVG should gain the `focusable` attribute. This is disabled by default since IE11
   * and Edge actually default this to true and keyboard's will tab focus all SVGs.
   */
  focusable: PropTypes.string,

  /**
   * An optional size to apply to the SVG. This can be used to set both the
   * `height` and `width` simultaneously. This will be provided as inline styles
   * since the `height` and `width` are normally controlled by CSS, and CSS has
   * higher precedence than the `height`/`width` attributes.
   */
  size: PropTypes.number,

  /**
   * The `height` prop should not be used since the `height` and `width` are controlled by CSS and the CSS
   * has a higher precedence than inline attributes. If you want to set the `height`, it should be done via
   * CSS or the `size` prop.
   *
   * @see {@link #size}
   */
  height: deprecated(PropTypes.number, 'Use the `size` prop instead'),

  /**
   * The `width` prop should not be used since the `height` and `width` are controlled by CSS and the CSS
   * has a higher precedence than inline attributes. If you want to set the `height`, it should be done via
   * CSS or the `size` prop.
   *
   * @see {@link #size}
   */
  width: deprecated(PropTypes.number, 'Use the `size` prop instead'),

  /**
   * The viewBox attribute allows you to specify that a given set of graphics stretch to
   * fit a particular container element.
   *
   * The value of the viewBox attribute is a list of four numbers min-x, min-y, width and
   * height, separated by white space and/or a comma, which specify a rectangle in user
   * space which should be mapped to the bounds of the viewport established by the given
   * element, taking into account attribute preserveAspectRatio.
   *
   * Negative values for width or height are not permitted and a value of zero disables
   * rendering of the element.An optional viewbox for the SVG.
   *
   * For example, if the SVG element is 250 (width) by 200 (height) and you provide
   * `viewBox="0 0 25 20"`, the coordinates inside the SVG will go from the top left corner
   * (0, 0) to the bottom right (25, 20) and each unit will be worth `10px`.
   */
  viewBox: PropTypes.string,

  /**
   * An optional xmlns string to provide. The `use` prop will not work without this prop
   * defined.
   */
  xmlns: PropTypes.string
};
SVGIcon.defaultProps = {
  role: 'img',
  focusable: 'false',
  xmlns: 'http://www.w3.org/2000/svg',
  viewBox: '0 0 24 24'
};
export default SVGIcon;