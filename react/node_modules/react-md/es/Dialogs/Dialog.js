var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { findDOMNode } from 'react-dom';
import cn from 'classnames';
import isRequiredForA11y from 'react-prop-types/lib/isRequiredForA11y';

import oneRequiredForA11y from '../utils/PropTypes/oneRequiredForA11y';
import FocusContainer from '../Helpers/FocusContainer';
import ResizeObserver from '../Helpers/ResizeObserver';
import Paper from '../Papers/Paper';
import DialogTitle from './DialogTitle';
import DialogFooter from './DialogFooter';

var DIFF_KEYS = ['style', 'height', 'width', 'contentStyle'];

/**
 * The `Dialog` is just a static component for creating dialogs. Dialogs
 * seemed like they could be used outside of the `DialogContainer` component,
 * so it was exposed as well. In *most* cases, you will still want to use
 * the `DialogContainer` component.
 */

var Dialog = function (_PureComponent) {
  _inherits(Dialog, _PureComponent);

  function Dialog(props) {
    _classCallCheck(this, Dialog);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this));

    _initialiseProps.call(_this);

    var height = props.height,
        width = props.width;

    var styles = props.style;
    if (height || width) {
      styles = styles || {};
      styles = _extends({ height: height, width: width }, styles);
    }

    _this.state = {
      styles: styles,
      contentStyles: props.contentStyle,
      contentPadded: false
    };
    return _this;
  }

  Dialog.prototype.getChildContext = function getChildContext() {
    return { renderNode: this._renderNode };
  };

  Dialog.prototype.componentWillMount = function componentWillMount() {
    var _props = this.props,
        pageX = _props.pageX,
        pageY = _props.pageY;

    if (!pageX || !pageY) {
      return;
    }

    this.setState({ styles: this._getStyles(this.props) });
  };

  Dialog.prototype.componentDidMount = function componentDidMount() {
    if (this.props.onOpen) {
      this.props.onOpen();
    }
  };

  Dialog.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (DIFF_KEYS.some(function (key) {
      return nextProps[key] !== _this2.props[key];
    })) {
      this.setState({
        styles: this._getStyles(nextProps),
        contentStyles: _extends({}, this.state.contentStyles, nextProps.contentStyle)
      });
    }
  };

  Dialog.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onLeave) {
      this.props.onLeave();
    }
  };

  Dialog.prototype.render = function render() {
    var _state = this.state,
        contentPadded = _state.contentPadded,
        styles = _state.styles,
        contentStyles = _state.contentStyles;

    var _props2 = this.props,
        id = _props2.id,
        className = _props2.className,
        titleStyle = _props2.titleStyle,
        titleClassName = _props2.titleClassName,
        footerStyle = _props2.footerStyle,
        footerClassName = _props2.footerClassName,
        contentClassName = _props2.contentClassName,
        title = _props2.title,
        Content = _props2.contentComponent,
        contentProps = _props2.contentProps,
        actions = _props2.actions,
        children = _props2.children,
        fullPage = _props2.fullPage,
        centered = _props2.centered,
        autopadContent = _props2.autopadContent,
        paddedContent = _props2.paddedContent,
        autosizeContent = _props2.autosizeContent,
        stackedActions = _props2.stackedActions,
        style = _props2.style,
        contentStyle = _props2.contentStyle,
        pageX = _props2.pageX,
        pageY = _props2.pageY,
        containerX = _props2.containerX,
        containerY = _props2.containerY,
        onOpen = _props2.onOpen,
        onLeave = _props2.onLeave,
        height = _props2.height,
        width = _props2.width,
        props = _objectWithoutProperties(_props2, ['id', 'className', 'titleStyle', 'titleClassName', 'footerStyle', 'footerClassName', 'contentClassName', 'title', 'contentComponent', 'contentProps', 'actions', 'children', 'fullPage', 'centered', 'autopadContent', 'paddedContent', 'autosizeContent', 'stackedActions', 'style', 'contentStyle', 'pageX', 'pageY', 'containerX', 'containerY', 'onOpen', 'onLeave', 'height', 'width']);

    var labelledBy = this.props['aria-labelledby'];

    var titleId = id + '-title';
    if (!labelledBy && title) {
      labelledBy = titleId;
    }

    var padDefined = typeof paddedContent !== 'undefined';
    var dialogChildren = fullPage ? children : [React.createElement(
      DialogTitle,
      {
        key: 'title',
        id: titleId,
        style: titleStyle,
        className: titleClassName
      },
      title
    ), React.createElement(
      Content,
      _extends({
        ref: !padDefined && autopadContent ? this._setContent : null,
        key: 'content'
      }, contentProps, {
        style: contentStyles,
        className: cn('md-dialog-content', {
          'md-dialog-content--padded': padDefined ? paddedContent : contentPadded
        }, contentClassName)
      }),
      autosizeContent ? React.createElement(ResizeObserver, { watchHeight: true, watchWidth: true, onResize: this._handleContentResize }) : null,
      children
    ), React.createElement(DialogFooter, {
      key: 'footer',
      style: footerStyle,
      className: footerClassName,
      actions: actions,
      stacked: stackedActions
    })];

    return React.createElement(
      Paper,
      _extends({}, props, {
        id: id,
        component: FocusContainer,
        ref: this._setRenderNode,
        style: styles,
        className: cn('md-dialog', {
          'md-dialog--full-page': fullPage,
          'md-dialog--centered': centered
        }, className),
        role: 'dialog',
        'aria-labelledby': labelledBy
      }),
      dialogChildren
    );
  };

  return Dialog;
}(PureComponent);

Dialog.propTypes = {
  /**
   * @see {@link Dialogs/DialogContainer#id}
   */
  id: isRequiredForA11y(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),

  /**
   * @see {@link Dialogs/DialogContainer#aria-describedby}
   */
  'aria-describedby': oneRequiredForA11y(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'title', 'aria-labelledby', 'aria-label'),

  /**
   * @see {@link Dialogs/DialogContainer#aria-labelledby}
   */
  'aria-labelledby': PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * @see {@link Dialogs/DialogContainer#aria-label}
   */
  'aria-label': PropTypes.string,

  /**
   * An optional style to apply to the dialog.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the dialog.
   */
  className: PropTypes.string,

  /**
   * An optional styke to apply to the title.
   */
  titleStyle: PropTypes.object,

  /**
   * An optional className to apply to the title.
   */
  titleClassName: PropTypes.string,

  /**
   * An optional style to apply to the footer. This is used when the `actions`
   * prop is defined.
   */
  footerStyle: PropTypes.object,

  /**
   * An optional className to apply to the footer. This is used when the `actions`
   * prop is defined.
   */
  footerClassName: PropTypes.string,

  /**
   * An optional style to apply to the dialog's content.
   */
  contentStyle: PropTypes.object,

  /**
   * An optional className to apply to the dialog's content.
   */
  contentClassName: PropTypes.string,

  /**
   * The component to render the content as. This is helpful if you would like to use
   * the CSSTransitionGroup. This really just saves a tiny bit of markup.
   *
   * ```js
   * <Dialog
   *   contentComponent={CSSTransitionGroup}
   *   contentProps={{
   *     transitionName: 'md-cross-fade',
   *     transitionLeave: false,
   *     transitionEnterTimeout: 150,
   *   }}
   * >
   *   {dynamicContent}
   * </Dialog>
   * ```
   */
  contentComponent: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,

  /**
   * Any additional props to pass to the content component.
   */
  contentProps: PropTypes.object,

  /**
   * An optional title to display in the dialog.
   */
  title: PropTypes.node,

  /**
   * Any children to display in the content of the dialog.
   */
  children: PropTypes.node,

  /**
   * A single action or a list of actions to display in the dialog. This can either be a list
   * of `FlatButton` props or `<Button flat {...props} />` elements.
   */
  actions: PropTypes.oneOfType([PropTypes.element, PropTypes.object, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.object]))]),

  /**
   * @see {@link Helpers/FocusContainer#additionalFocusKeys}
   */
  additionalFocusKeys: FocusContainer.propTypes.additionalFocusKeys,

  /**
   * @see {@link Helpers/FocusContainer#initialFocus}
   */
  initialFocus: FocusContainer.propTypes.initialFocus,

  /**
   * @see {@link Helpers/FocusContainer#focusOnMount}
   */
  focusOnMount: FocusContainer.propTypes.focusOnMount,

  /**
   * @see {@link Helpers/FocusContainer#containFocus}
   */
  containFocus: FocusContainer.propTypes.containFocus,

  /**
   * An optional x coordinate on the page that caused a full page dialog
   * to be created. This is really just used for a `transformOrigin` style.
   */
  pageX: PropTypes.number,

  /**
   * An optional y coordinate on the page that caused a full page dialog
   * to be created. This is really just used for a `transformOrigin` style.
   */
  pageY: PropTypes.number,

  /**
   * An optional x scroll position of the container holding the dialog. This
   * is really just used for a `transformOrigin` style on full page dialogs.
   */
  containerX: PropTypes.number,

  /**
   * An optional y scroll position of the container holding the dialog. This
   * is really just used for a `transformOrigin` style on full page dialogs.
   */
  containerY: PropTypes.number,

  /**
   * Boolean if the dialog should be rendered as a full page dialog.
   */
  fullPage: PropTypes.bool,

  /**
   * The zDepth to use for the dialog.
   */
  zDepth: PropTypes.number.isRequired,

  /**
   * An optional function to call when the dialog has been opened. This is
   * really just used for the `DialogContainer`.
   */
  onOpen: PropTypes.func,

  /**
   * An optional function to call when the dialog has been closed. This is
   * really just used for the `DialogContainer`.
   */
  onLeave: PropTypes.func,

  /**
   * Boolean if the dialog should be centered in the page.
   */
  centered: PropTypes.bool,

  /**
   * Boolean if the content should be padded. This will take precedence
   * over the `autopadContent` prop. So if this is defined, that value
   * will be used instead of any thing that was was calculated in this
   * component.
   *
   * @see {@link #autopadContent}
   */
  paddedContent: PropTypes.bool,

  /**
   * Boolean if the dialog should automatically try to determine if the content
   * should be padded. It will be padded if the dialog does not contain a `List`.
   */
  autopadContent: PropTypes.bool,

  /**
   * Boolean if the dialog content's size should automatically be resized to overflow
   * correctly when there is a lot of content. This will calculate and apply some `maxHeight`
   * to the `contentStyle`.
   */
  autosizeContent: PropTypes.bool,

  /**
   * An optional height to apply to the dialog. This is used if it is easier to just apply height/width
   * with for specific dialogs instead of in CSS.
   *
   * **This prop should not be used if the `fullPage` prop is enabled.**
   *
   * @see {@link #fullPage}
   * @see {@link #width}
   */
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * An optional width to apply to the dialog. This is used if it is easier to just apply height/width
   * with for specific dialogs instead of in CSS.
   *
   * **This prop should not be used if the `fullPage` prop is enabled.**
   *
   * @see {@link #fullPage}
   * @see {@link #height}
   */
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Boolean if the actions should be stacked on top of each other. If this value is `undefined`, it will
   * automatically attempt to guess if the items should be stacked.
   */
  stackedActions: PropTypes.bool
};
Dialog.defaultProps = {
  autopadContent: true,
  autosizeContent: true,
  contentComponent: 'section',
  zDepth: 5
};
Dialog.childContextTypes = {
  renderNode: PropTypes.object
};

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this._getStyles = function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this3.props,
        pageX = _ref.pageX,
        containerX = _ref.containerX,
        pageY = _ref.pageY,
        containerY = _ref.containerY,
        height = _ref.height,
        width = _ref.width,
        style = _ref.style;

    return _extends({
      height: typeof height !== 'undefined' ? height : null,
      width: typeof width !== 'undefined' ? width : null,
      transformOrigin: pageX || pageY ? pageX - containerX + 'px ' + (pageY - containerY) + 'px' : null
    }, style);
  };

  this._setRenderNode = function (dialog) {
    _this3._renderNode = findDOMNode(dialog);
  };

  this._setContent = function (content) {
    if (content !== null) {
      _this3._content = findDOMNode(content);
      var contentPadded = _this3._content.querySelectorAll('.md-list').length === 0;

      _this3.setState({ contentPadded: contentPadded });
    }
  };

  this._handleContentResize = function (_ref2) {
    var scrollHeight = _ref2.scrollHeight,
        content = _ref2.el;

    var maxHeight = content.style.maxHeight;
    var dialog = content.parentNode;
    content.style.maxHeight = 'none';
    var title = _this3.props.title ? dialog.querySelector('.md-title--dialog') : null;
    var footer = _this3.props.actions ? dialog.querySelector('.md-dialog-footer') : null;

    var totalHeight = dialog.offsetHeight - (title ? title.offsetHeight : 0) - (footer ? footer.offsetHeight : 0);
    content.style.maxHeight = maxHeight;
    var equalHeight = totalHeight === scrollHeight;
    if (equalHeight) {
      var currentHeight = _this3.state.contentStyles && _this3.state.contentStyles.maxHeight || null;
      if (currentHeight && currentHeight !== scrollHeight) {
        _this3.setState({ contentStyles: _this3.props.contentStyle });
      }
    } else {
      _this3.setState({ contentStyles: _extends({ maxHeight: totalHeight }, _this3.props.contentStyle) });
    }
  };
};

export default Dialog;