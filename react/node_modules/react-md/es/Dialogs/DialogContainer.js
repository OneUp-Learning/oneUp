var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { findDOMNode } from 'react-dom';
import CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';
import cn from 'classnames';
import deprecated from 'react-prop-types/lib/deprecated';
import isRequiredForA11y from 'react-prop-types/lib/isRequiredForA11y';

import { ESC } from '../constants/keyCodes';
import TICK from '../constants/CSSTransitionGroupTick';
import getField from '../utils/getField';
import toggleScroll from '../utils/toggleScroll';
import oneRequiredForA11y from '../utils/PropTypes/oneRequiredForA11y';
import Dialog from './Dialog';
import Portal from '../Helpers/Portal';

/**
 * The `DialogContainer` component is used for dynamically creating the `Dialog` with
 * transitions.
 */

var DialogContainer = function (_PureComponent) {
  _inherits(DialogContainer, _PureComponent);

  function DialogContainer(props) {
    _classCallCheck(this, DialogContainer);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _initialiseProps.call(_this);

    var visible = typeof props.isOpen !== 'undefined' ? props.isOpen : props.visible;
    var dialogVisible = visible && !props.defaultVisibleTransitionable;

    _this.state = {
      active: visible && !props.fullPage,
      portalVisible: visible,
      dialogVisible: dialogVisible
    };
    return _this;
  }
  /* eslint-disable max-len */


  DialogContainer.prototype.componentDidMount = function componentDidMount() {
    if (!this.props.isOpen && !this.props.visible) {
      return;
    }

    this._mountDialog(this.props);
  };

  DialogContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var visible = typeof nextProps.isOpen !== 'undefined' ? nextProps.isOpen : nextProps.visible;
    if (this.props.isOpen === visible || this.props.visible === visible) {
      return;
    }

    var el = getField(this.props, this.context, 'renderNode') || window;
    var pageX = el.scrollX,
        pageY = el.scrollY;

    if (typeof el.scrollTop !== 'undefined' && typeof el.scrollLeft !== 'undefined') {
      pageX = el.scrollLeft;
      pageY = el.scrollTop;
    } else if (typeof el.scrollY !== 'undefined' && typeof el.scrollX !== 'undefined') {
      pageX = el.scrollX;
      pageY = el.scrollY;
    }

    this._pageX = pageX;
    this._pageY = pageY;

    if (this._inTimeout) {
      clearTimeout(this._inTimeout);
      this._inTimeout = null;
    }

    if (visible) {
      this._activeElement = document.activeElement;
      this._mountPortal(nextProps);
    } else {
      this.setState({ dialogVisible: false, active: false });
    }
  };

  DialogContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _props = this.props,
        visible = _props.visible,
        closeOnEsc = _props.closeOnEsc;

    // Only going to support visible here since it was not implemented before.

    if (visible === prevProps.visible && closeOnEsc === prevProps.closeOnEsc) {
      return;
    }

    var add = false;
    var remove = false;
    if (closeOnEsc !== prevProps.closeOnEsc) {
      add = visible && closeOnEsc;
      remove = !visible || prevProps.closeOnEsc && !closeOnEsc;
    } else if (closeOnEsc) {
      add = visible;
      remove = !visible;
    }

    if (add) {
      window.addEventListener('keydown', this._handleEscClose);
    } else if (remove) {
      window.removeEventListener('keydown', this._handleEscClose);
    }
  };

  DialogContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.isOpen || this.props.visible) {
      toggleScroll(false);
    }

    if (this.props.visible && this.props.closeOnEsc) {
      window.removeEventListener('keydown', this._handleEscClose);
    }

    if (this._inTimeout) {
      clearTimeout(this._inTimeout);
    }
  };

  DialogContainer.prototype.render = function render() {
    var _state = this.state,
        active = _state.active,
        dialogVisible = _state.dialogVisible,
        portalVisible = _state.portalVisible;

    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        dialogStyle = _props2.dialogStyle,
        dialogClassName = _props2.dialogClassName,
        modal = _props2.modal,
        fullPage = _props2.fullPage,
        component = _props2.component,
        transitionEnterTimeout = _props2.transitionEnterTimeout,
        transitionLeaveTimeout = _props2.transitionLeaveTimeout,
        lastChild = _props2.lastChild,
        portal = _props2.portal,
        propVisible = _props2.visible,
        propRenderNode = _props2.renderNode,
        closeOnEsc = _props2.closeOnEsc,
        onShow = _props2.onShow,
        onHide = _props2.onHide,
        disableScrollLocking = _props2.disableScrollLocking,
        defaultVisibleTransitionable = _props2.defaultVisibleTransitionable,
        close = _props2.close,
        isOpen = _props2.isOpen,
        actionLeft = _props2.actionLeft,
        actionRight = _props2.actionRight,
        transitionName = _props2.transitionName,
        transitionEnter = _props2.transitionEnter,
        transitionLeave = _props2.transitionLeave,
        props = _objectWithoutProperties(_props2, ['style', 'className', 'dialogStyle', 'dialogClassName', 'modal', 'fullPage', 'component', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'lastChild', 'portal', 'visible', 'renderNode', 'closeOnEsc', 'onShow', 'onHide', 'disableScrollLocking', 'defaultVisibleTransitionable', 'close', 'isOpen', 'actionLeft', 'actionRight', 'transitionName', 'transitionEnter', 'transitionLeave']);

    var renderNode = getField(this.props, this.context, 'renderNode');
    var dialog = React.createElement(Dialog, _extends({
      key: 'dialog',
      style: dialogStyle,
      className: cn('md-background--card', dialogClassName),
      ref: this._handleDialogMounting,
      centered: !fullPage,
      fullPage: fullPage
    }, props, {
      containerX: this._pageX,
      containerY: this._pageY,
      onLeave: this._unmountPortal
    }));

    var container = React.createElement(
      CSSTransitionGroup,
      {
        component: component,
        ref: this._setContainer,
        style: style,
        className: cn('md-dialog-container', {
          'md-overlay': !fullPage,
          'md-overlay--active': !fullPage && active && propVisible,
          'md-pointer--hover': !fullPage && !modal && propVisible
        }, className),
        transitionName: 'md-dialog--' + (fullPage ? 'full-page' : 'centered'),
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout,
        tabIndex: -1,
        onClick: this._handleClick
      },
      dialogVisible ? dialog : null
    );

    if (!portal) {
      return portalVisible ? container : null;
    }

    return React.createElement(
      Portal,
      { visible: portalVisible, renderNode: renderNode, lastChild: lastChild },
      container
    );
  };

  return DialogContainer;
}(PureComponent);

DialogContainer.propTypes = {
  /**
   * An id to use for the `Dialog` once it has been opened. This is used for the
   * [dialog role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_dialog_role).
   * This is used to generate an `id` for the `title` prop when it has been defined.
   */
  id: isRequiredForA11y(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),
  /* eslint-enable max-len */

  /**
   * An optional accessibility prop to use when the `Dialog` is opened. This should be an id
   * pointing to some text that describes the content of the dialog. For accessibility
   * reasons, one of the following props must be defined:
   * - `title`
   * - `aria-describedby`
   * - `aria-labelledby`
   * - `aria-label`
   *
   * An example usage:
   *
   * ```js
   * <Dialog id="accessible-example" visible aria-describedby="accessible-content">
   *   <p id="accessible-content">This is some content that describes the dialog.</p>
   * </Dialog>
   * ```
   */
  'aria-describedby': oneRequiredForA11y(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'title', 'aria-labelledby', 'aria-label'),

  /**
   * An optional accessibility prop to use when the `title` prop is not given. This should be
   * an id pointing to a `h` tag that labels the dialog.
   *
   * An example usage:
   *
   * ```js
   * <Dialog visible id="accessible-example" aria-labelledby="accessible-dialog-label">
   *   <h2 id="accessible-dialog-label">Some Accessible Dialog</h2>
   * </Dialog>
   * ```
   */
  'aria-labelledby': PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * An optional accessibility prop to use when the `title` and `aria-labelledby` props are
   * not defined. This should be a string that describes what is in the `Dialog`.
   *
   * An example usage:
   *
   * ```js
   * <Dialog visible id="accessible-example" aria-label="Some Accessible Dialog">
   *   <p>Lorem Ipsum</p>
   * </Dialog>
   * ```
   */
  'aria-label': PropTypes.string,

  /**
   * An optional style to apply to the dialog's container.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the dialog's container.
   */
  className: PropTypes.string,

  /**
   * An optional style to apply to the dialog itself when the `visible` prop is `true`.
   */
  dialogStyle: PropTypes.object,

  /**
   * An optional className to apply to the dialog itself when the `visible` prop is `true`.
   */
  dialogClassName: PropTypes.string,

  /**
   * An optional styke to apply to the title.
   */
  titleStyle: PropTypes.object,

  /**
   * An optional className to apply to the title.
   */
  titleClassName: PropTypes.string,

  /**
   * An optional style to apply to the footer. This is used when the `actions`
   * prop is defined.
   */
  footerStyle: PropTypes.object,

  /**
   * An optional className to apply to the footer. This is used when the `actions`
   * prop is defined.
   */
  footerClassName: PropTypes.string,

  /**
   * An optional style to apply to the dialog's content.
   */
  contentStyle: PropTypes.object,

  /**
   * An optional className to apply to the dialog's content.
   */
  contentClassName: PropTypes.string,

  /**
   * The component to render the dialog's container in.
   */
  component: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.object]).isRequired,

  /**
   * The component to render the dialog's content in.
   */
  contentComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.object]).isRequired,

  /**
   * The content to display in the dialog once open.
   */
  children: PropTypes.node,

  /**
   * A single action or a list of actions to display in the dialog. This can either be a list
   * of `FlatButton` props or `<Button flat {...props} />` elements.
   */
  actions: PropTypes.oneOfType([PropTypes.element, PropTypes.object, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.object]))]),

  /**
   * Boolean if the `Dialog` is current visible.
   */
  visible: PropTypes.bool.isRequired,

  /**
   * An optional function to call when the `visible` prop is changed from `false` to `true`.
   */
  onShow: PropTypes.func,

  /**
   * A function to call that will close the dialog. This is required when the `modal` and `fullPage`
   * props are not `true`.
   */
  onHide: function onHide(props, propName) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var validator = PropTypes.func;
    if (!props.modal && !props.fullPage) {
      validator = validator.isRequired;
    }

    return validator.apply(undefined, [props, propName].concat(args));
  },

  /**
   * Boolean if the dialog should behave like a modal. This means that the dialog can only
   * be closed by clicking on an action instead of also clicking on the overlay.
   *
   * NOTE: Unless the `closeOnEsc` prop is disabled as well, the user can still press the escape
   * key to close this modal.
   */
  modal: PropTypes.bool,

  /**
   * Boolean if the dialog should be displayed as a full page dialog.
   */
  fullPage: function fullPage(props, propName, componentName) {
    for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      args[_key2 - 3] = arguments[_key2];
    }

    var componentNameSafe = componentName || '<<anonymous>>';
    var err = PropTypes.bool.apply(PropTypes, [props, propName, componentName].concat(args));

    if (!err && props[propName] && typeof props.title !== 'undefined') {
      err = new Error('You provided a `title` ' + location + ' to the `' + componentNameSafe + '` when `fullPage` ' + 'has been set to true. A title for a full page dialog should be rendered as a child instead.');
    }

    return err;
  },

  /**
   * An optional pageX location to use when rendering a full page dialog. This is used to set the location
   * the dialog should appear from.
   */
  pageX: PropTypes.number,

  /**
   * An optional pageY location to use when rendering a full page dialog. This is used to set the location
   * the dialog should appear from.
   */
  pageY: PropTypes.number,

  /**
   * @see {@link Helpers/FocusContainer#additionalFocusKeys}
   */
  additionalFocusKeys: Dialog.propTypes.additionalFocusKeys,

  /**
   * @see {@link Helpers/FocusContainer#initialFocus}
   */
  initialFocus: Dialog.propTypes.initialFocus,

  /**
   * @see {@link Helpers/FocusContainer#focusOnMount}
   */
  focusOnMount: Dialog.propTypes.focusOnMount,

  /**
   * @see {@link Helpers/FocusContainer#containFocus}
   */
  containFocus: Dialog.propTypes.containFocus,

  /**
   * The transition enter timeout for the dialog.
   */
  transitionEnterTimeout: PropTypes.number.isRequired,

  /**
   * The transition leave timeout for the dialog.
   */
  transitionLeaveTimeout: PropTypes.number.isRequired,

  /**
   * Boolean if the dialog should be closable by pressing the escape key.
   */
  closeOnEsc: PropTypes.bool,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the dialog.
   *
   * @see {@link Helpers/Portal}
   */
  portal: PropTypes.bool,

  /**
   * Since the `Dialog` uses the `Portal` component, you can pass an optional HTML Node to render
   * the dialog in instead of the `document.body`.
   */
  renderNode: PropTypes.object,

  /**
   * Boolean if the dialog should be rendered as the last child in the `renderNode` or `body` instead
   * of as the first.
   */
  lastChild: PropTypes.bool,

  /**
   * An optional title for the dialog.
   */
  title: PropTypes.node,

  /**
   * Boolean if the dialog should animate into view if it is constructed with `visible` enabled.
   *
   * This basically means that if the `Dialog` has `visible` enabled on initial page load, does it animate?
   * In some cases, it can also mean if the `Dialog` is added to the render tree with `visible` enabled,
   * does it animate?
   */
  defaultVisibleTransitionable: PropTypes.bool,

  /**
   * Boolean if the Dialog should no longer try to prevent the parent container from scrolling while visible.
   * In most cases, this will attempt to prevent the main window scrolling. If this dialog is nested in another
   * dialog, it will attempt to prevent the parent dialog from scrolling.
   */
  disableScrollLocking: PropTypes.bool,

  /**
   * Boolean if the dialog should automatically try to determine if the content
   * should be padded. It will be padded if the dialog does not contain a `List`.
   */
  autopadContent: PropTypes.bool,

  /**
   * Boolean if the dialog content's size should automatically be resized to overflow
   * correctly when there is a lot of content. This will calculate and apply some `maxHeight`
   * to the `contentStyle`.
   */
  autosizeContent: PropTypes.bool,

  /**
   * An optional height to apply to the dialog. This is used if it is easier to just apply height/width
   * with for specific dialogs instead of in CSS.
   *
   * **This prop should not be used if the `fullPage` prop is enabled.**
   *
   * @see {@link #fullPage}
   * @see {@link #width}
   */
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * An optional width to apply to the dialog. This is used if it is easier to just apply height/width
   * with for specific dialogs instead of in CSS.
   *
   * **This prop should not be used if the `fullPage` prop is enabled.**
   *
   * @see {@link #fullPage}
   * @see {@link #height}
   */
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Boolean if the actions should be stacked on top of each other. If this value is `undefined`, it will
   * automatically attempt to guess if the items should be stacked.
   */
  stackedActions: PropTypes.bool,

  isOpen: deprecated(PropTypes.bool, 'Use `visible` instead'),
  transitionName: deprecated(PropTypes.string, 'The transition name will be managed by the component'),
  transitionEnter: deprecated(PropTypes.bool, 'The transition will always be enforced'),
  transitionLeave: deprecated(PropTypes.bool, 'The transition will always be enforced'),
  actionLeft: deprecated(PropTypes.node, 'Use the `fullPage` prop instead'),
  actionRight: deprecated(PropTypes.node, 'Use the `fullPage` prop instead'),
  close: deprecated(PropTypes.func, 'Use `onHide` instead')
};
DialogContainer.defaultProps = {
  autopadContent: true,
  autosizeContent: true,
  component: 'span',
  closeOnEsc: true,
  contentComponent: 'section',
  focusOnMount: true,
  transitionEnterTimeout: 300,
  transitionLeaveTimeout: 300,
  defaultVisibleTransitionable: false
};
DialogContainer.contextTypes = {
  renderNode: PropTypes.object
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setContainer = function (container) {
    if (container !== null) {
      _this2._container = findDOMNode(container);
    }
  };

  this._handleEscClose = function (e) {
    if ((e.which || e.keyCode) === ESC) {
      (_this2.props.onHide || _this2.props.close)(e);
    }
  };

  this._mountPortal = function (props) {
    _this2._mountDialog(props);
    _this2.setState({ portalVisible: true });
  };

  this._mountDialog = function (props) {
    var fullPage = props.fullPage,
        onShow = props.onShow;

    _this2._inTimeout = setTimeout(function () {
      _this2._inTimeout = fullPage ? null : setTimeout(function () {
        _this2._inTimeout = null;
        _this2.setState({ active: true });
      }, TICK);
      _this2.setState({ dialogVisible: true }, onShow);
    }, TICK);
  };

  this._unmountPortal = function () {
    _this2.setState({ portalVisible: false });
  };

  this._handleClick = function (e) {
    var visible = typeof _this2.props.isOpen !== 'undefined' ? _this2.props.isOpen : _this2.props.visible;
    if (_this2.props.modal || !visible || e.target !== _this2._container) {
      return;
    }

    (_this2.props.onHide || _this2.props.close)(e);
  };

  this._handleDialogMounting = function (dialog) {
    var disableScrollLocking = _this2.props.disableScrollLocking;

    if (dialog === null) {
      if (_this2._activeElement && _this2._activeElement.focus) {
        _this2._activeElement.focus();
      }

      if (!disableScrollLocking) {
        toggleScroll(false, _this2.scrollEl);
      }

      _this2._activeElement = null;
    } else {
      var container = document.getElementById(_this2.props.id);
      if (!container || disableScrollLocking) {
        return;
      }

      var el = getField(_this2.props, _this2.context, 'renderNode');
      var node = container.parentNode;
      while (node && node.classList && !el) {
        if (node.classList.contains('md-dialog')) {
          el = node;
        }

        node = node.parentNode;
      }

      _this2.scrollEl = el;
      toggleScroll(true, el);
    }
  };
};

export default DialogContainer;