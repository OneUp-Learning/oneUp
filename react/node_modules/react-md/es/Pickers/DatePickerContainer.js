var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable new-cap,no-shadow */
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import isRequiredForA11y from 'react-prop-types/lib/isRequiredForA11y';
import deprecated from 'react-prop-types/lib/deprecated';

import { ESC, TAB } from '../constants/keyCodes';
import getField from '../utils/getField';
import handleWindowClickListeners from '../utils/EventUtils/handleWindowClickListeners';
import handleKeyboardAccessibility from '../utils/EventUtils/handleKeyboardAccessibility';
import controlled from '../utils/PropTypes/controlled';
import addDate from '../utils/dates/addDate';
import isSameDay from '../utils/dates/isSameDay';
import DateTimeFormat from '../utils/DateUtils/DateTimeFormat';

import Collapse from '../Helpers/Collapse';
import FontIcon from '../FontIcons/FontIcon';
import getDeprecatedIcon from '../FontIcons/getDeprecatedIcon';
import TextField from '../TextFields/TextField';
import Dialog from '../Dialogs/DialogContainer';
import DatePicker from './DatePicker';

/**
 * The `DatePickerContainer` component is a wrapper for the main `DatePicker` component
 * to manage the state and _logic_ for rendering the `DatePicker`. This component will
 * either render inline or in a `Dialog` depending if the `inline` prop is set to `true`.
 *
 * NOTE: This component is actually exported as `DatePicker` when using the `import { member }` syntax.
 * The following two lines are equivalent:
 *
 * ```js
 * import { DatePicker } from 'react-md/lib/Pickers';
 * import DatePicker from 'react-md/lib/Pickers/DatePickerContainer';
 * ```
 */

var DatePickerContainer = function (_PureComponent) {
  _inherits(DatePickerContainer, _PureComponent);

  function DatePickerContainer(props) {
    _classCallCheck(this, DatePickerContainer);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _initialiseProps.call(_this);

    var date = void 0;
    var value = void 0;
    var defaultValue = props.defaultValue,
        DateTimeFormat = props.DateTimeFormat,
        locales = props.locales,
        formatOptions = props.formatOptions,
        minDate = props.minDate,
        maxDate = props.maxDate;


    if (typeof props.value !== 'undefined') {
      date = _this._getDate(props.value);
    } else if (defaultValue) {
      date = _this._getDate(defaultValue);
      value = typeof defaultValue === 'string' ? defaultValue : DateTimeFormat(locales, formatOptions).format(defaultValue);
    } else {
      date = new Date();
      value = '';
    }

    date = _this._validateDateRange(date, minDate, maxDate);

    var defaultCalendarDate = typeof props.initialCalendarDate !== 'undefined' ? props.initialCalendarDate : props.defaultCalendarDate;
    var calendarTempDate = date;
    if (typeof defaultCalendarDate !== 'undefined' && !props.value && !props.defaultValue) {
      calendarTempDate = _this._getDate(defaultCalendarDate);
      date = calendarTempDate;
    } else if (calendarTempDate === null) {
      calendarTempDate = new Date();
      date = new Date();
    }

    var visible = typeof props.initiallyOpen !== 'undefined' ? props.initiallyOpen : !!props.defaultVisible;

    _this.state = {
      value: value,
      visible: visible,
      calendarDate: date,
      calendarTempDate: calendarTempDate,
      calendarMode: props.initialCalendarMode || props.defaultCalendarMode
    };
    return _this;
  }

  DatePickerContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var value = nextProps.value,
        minDate = nextProps.minDate,
        maxDate = nextProps.maxDate;

    var minEqual = isSameDay(this.props.minDate, minDate);
    var maxEqual = isSameDay(this.props.maxDate, maxDate);
    if (this.props.value !== value || !minEqual || !maxEqual) {
      var calendarDate = this.state.calendarDate;

      if (typeof value !== 'undefined') {
        calendarDate = this._getDate(value);
      }

      calendarDate = this._validateDateRange(calendarDate, minDate, maxDate);

      if (!isSameDay(this.state.calendarDate, calendarDate)) {
        this.setState({ calendarDate: calendarDate, calendarTempDate: calendarDate });
      }
    }
  };

  DatePickerContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var _props = this.props,
        inline = _props.inline,
        isOpen = _props.isOpen;

    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(this.props, this.state, 'visible');
    var pVisible = typeof prevProps.isOpen !== 'undefined' ? prevProps.isOpen : getField(prevProps, prevState, 'visible');

    if (visible === pVisible) {
      return;
    }

    if (visible) {
      if (inline) {
        handleWindowClickListeners(this._handleOutsideClick, true);
        window.addEventListener('keydown', this._closeOnEsc);
      }
    } else if (inline) {
      handleWindowClickListeners(this._handleOutsideClick, false);
      window.removeEventListener('keydown', this._closeOnEsc);
    }
  };

  DatePickerContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    var visible = typeof this.props.isOpen !== 'undefined' ? this.props.isOpen : getField(this.props, this.state, 'visible');

    if (visible && this.props.inline) {
      handleWindowClickListeners(this._handleOutsideClick, false);
      window.removeEventListener('keydown', this._closeOnEsc);
    }
  };

  DatePickerContainer.prototype._getDate = function _getDate(value) {
    if (value === '' || value === null) {
      return new Date();
    } else if (typeof value === 'string') {
      return new Date(value);
    }

    return value;
  };

  /**
   * Gets the current value from the date picker as a formatted string.
   *
   * @param {Object} props? the props object to use.
   * @param {Object} state? the state object to use.
   * @return {String} a formatted date string or the empty string.
   */
  DatePickerContainer.prototype._getFormattedValue = function _getFormattedValue(props, state) {
    var DateTimeFormat = props.DateTimeFormat,
        locales = props.locales,
        formatOptions = props.formatOptions;

    var value = getField(props, state, 'value');
    if (!value) {
      return '';
    } else if (value instanceof Date) {
      return DateTimeFormat(locales, formatOptions).format(new Date(value));
    } else {
      return value;
    }
  };

  /**
   * Attempts to validate the `calendarDate` in the state against the min and
   * max dates.
   *
   * This will return null if the current calendarDate is still within the range.
   *
   * @param {Date} calendarDate - The current calendar date to compare to.
   * @param {Date} minDate - An optional min date to compare to.
   * @param {Date} maxDate - An optional max date to compare to.
   * @return {Object} - The new state object with the updated calendarDate and
   *    calendarTempDate keys or null.
   */


  DatePickerContainer.prototype._validateDateRange = function _validateDateRange(calendarDate, minDate, maxDate) {
    var date = calendarDate;
    if (minDate && minDate > calendarDate) {
      date = new Date(minDate);
    }

    if (maxDate && maxDate < calendarDate) {
      date = new Date(maxDate);
    }

    return date;
  };

  DatePickerContainer.prototype.render = function render() {
    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        pickerStyle = _props2.pickerStyle,
        pickerClassName = _props2.pickerClassName,
        pickerHeaderClassName = _props2.pickerHeaderClassName,
        pickerContentClassName = _props2.pickerContentClassName,
        pickerFooterClassName = _props2.pickerFooterClassName,
        inputStyle = _props2.inputStyle,
        inputClassName = _props2.inputClassName,
        textFieldStyle = _props2.textFieldStyle,
        textFieldClassName = _props2.textFieldClassName,
        label = _props2.label,
        placeholder = _props2.placeholder,
        icon = _props2.icon,
        inline = _props2.inline,
        displayMode = _props2.displayMode,
        fullWidth = _props2.fullWidth,
        lineDirection = _props2.lineDirection,
        id = _props2.id,
        disabled = _props2.disabled,
        closeOnEsc = _props2.closeOnEsc,
        animateInline = _props2.animateInline,
        portal = _props2.portal,
        renderNode = _props2.renderNode,
        lastChild = _props2.lastChild,
        block = _props2.block,
        paddedBlock = _props2.paddedBlock,
        active = _props2.active,
        error = _props2.error,
        floating = _props2.floating,
        required = _props2.required,
        leftIconStateful = _props2.leftIconStateful,
        rightIcon = _props2.rightIcon,
        rightIconStateful = _props2.rightIconStateful,
        customSize = _props2.customSize,
        errorText = _props2.errorText,
        helpText = _props2.helpText,
        helpOnFocus = _props2.helpOnFocus,
        inlineIndicator = _props2.inlineIndicator,
        disableScrollLocking = _props2.disableScrollLocking,
        ariaLabel = _props2['aria-label'],
        propNextIcon = _props2.nextIcon,
        propPreviousIcon = _props2.previousIcon,
        isOpen = _props2.isOpen,
        previousIconChildren = _props2.previousIconChildren,
        previousIconClassName = _props2.previousIconClassName,
        nextIconChildren = _props2.nextIconChildren,
        nextIconClassName = _props2.nextIconClassName,
        propValue = _props2.value,
        propVisible = _props2.visible,
        defaultValue = _props2.defaultValue,
        defaultVisible = _props2.defaultVisible,
        onChange = _props2.onChange,
        readOnly = _props2.readOnly,
        onVisibilityChange = _props2.onVisibilityChange,
        defaultCalendarDate = _props2.defaultCalendarDate,
        getDateClassName = _props2.getDateClassName,
        dateRenderer = _props2.dateRenderer,
        initialCalendarDate = _props2.initialCalendarDate,
        initiallyOpen = _props2.initiallyOpen,
        adjustMinWidth = _props2.adjustMinWidth,
        props = _objectWithoutProperties(_props2, ['style', 'className', 'pickerStyle', 'pickerClassName', 'pickerHeaderClassName', 'pickerContentClassName', 'pickerFooterClassName', 'inputStyle', 'inputClassName', 'textFieldStyle', 'textFieldClassName', 'label', 'placeholder', 'icon', 'inline', 'displayMode', 'fullWidth', 'lineDirection', 'id', 'disabled', 'closeOnEsc', 'animateInline', 'portal', 'renderNode', 'lastChild', 'block', 'paddedBlock', 'active', 'error', 'floating', 'required', 'leftIconStateful', 'rightIcon', 'rightIconStateful', 'customSize', 'errorText', 'helpText', 'helpOnFocus', 'inlineIndicator', 'disableScrollLocking', 'aria-label', 'nextIcon', 'previousIcon', 'isOpen', 'previousIconChildren', 'previousIconClassName', 'nextIconChildren', 'nextIconClassName', 'value', 'visible', 'defaultValue', 'defaultVisible', 'onChange', 'readOnly', 'onVisibilityChange', 'defaultCalendarDate', 'getDateClassName', 'dateRenderer', 'initialCalendarDate', 'initiallyOpen', 'adjustMinWidth']);

    var nextIcon = getDeprecatedIcon(nextIconClassName, nextIconChildren, propNextIcon);
    var previousIcon = getDeprecatedIcon(previousIconClassName, previousIconChildren, propPreviousIcon);
    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(this.props, this.state, 'visible');

    var picker = React.createElement(DatePicker, _extends({}, this.state, props, {
      nextIcon: nextIcon,
      previousIcon: previousIcon,
      icon: !!icon,
      inline: inline,
      style: pickerStyle,
      className: pickerClassName,
      headerClassName: pickerHeaderClassName,
      contentClassName: pickerContentClassName,
      footerClassName: pickerFooterClassName,
      displayMode: displayMode,
      onCancelClick: this._handleCancelClick,
      onOkClick: this._handleOkClick,
      changeCalendarMode: this._changeCalendarMode,
      onPreviousClick: this._previousMonth,
      onNextClick: this._nextMonth,
      onCalendarDateClick: this._setCalendarTempDate,
      onCalendarYearClick: this._setCalendarTempYear,
      getDateClassName: getDateClassName,
      dateRenderer: dateRenderer
    }));

    var content = void 0;
    if (inline) {
      content = React.createElement(
        Collapse,
        { collapsed: !visible, animate: animateInline },
        picker
      );
    } else {
      content = React.createElement(
        Dialog,
        {
          id: id + '-dialog',
          visible: visible,
          onHide: this._handleCancelClick,
          dialogClassName: 'md-dialog--picker',
          contentClassName: 'md-dialog-content--picker',
          'aria-label': ariaLabel,
          closeOnEsc: closeOnEsc,
          renderNode: renderNode,
          portal: portal,
          lastChild: lastChild,
          focusOnMount: false,
          disableScrollLocking: disableScrollLocking
        },
        picker
      );
    }

    return React.createElement(
      'div',
      { style: style, className: cn('md-picker-container', className), ref: this._setContainer },
      React.createElement(TextField, {
        id: id,
        style: textFieldStyle,
        className: cn({ 'md-pointer--hover': !disabled }, textFieldClassName),
        inputStyle: inputStyle,
        inputClassName: cn({ 'md-pointer--hover': !disabled }, inputClassName),
        active: active || visible,
        error: error,
        floating: floating || visible,
        required: required,
        disabled: disabled,
        leftIcon: icon,
        leftIconStateful: leftIconStateful,
        rightIcon: rightIcon,
        rightIconStateful: rightIconStateful,
        inlineIndicator: inlineIndicator,
        block: block,
        paddedBlock: paddedBlock,
        fullWidth: fullWidth,
        lineDirection: lineDirection,
        customSize: customSize,
        helpText: helpText,
        helpOnFocus: helpOnFocus,
        errorText: errorText,
        label: label,
        placeholder: placeholder,
        onClick: this._toggleOpen,
        onKeyDown: this._handleKeyDown,
        value: this._getFormattedValue(this.props, this.state),
        readOnly: true
      }),
      content
    );
  };

  return DatePickerContainer;
}(PureComponent);

DatePickerContainer.propTypes = {
  /**
   * An id for the text field in the date picker. This is require for a11y.
   */
  id: isRequiredForA11y(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),

  /**
   * An aria label for the dialog. This is required for a11y.
   */
  'aria-label': isRequiredForA11y(PropTypes.string),

  /**
   * An optional style to apply to the date picker's container.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the date picker's container.
   */
  className: PropTypes.string,

  /**
   * An optional style to apply to the date picker.
   */
  pickerStyle: PropTypes.object,

  /**
   * An optional className to apply to the date picker.
   */
  pickerClassName: PropTypes.string,

  /**
   * An optional className to apply to the header of date picker.
   */
  pickerHeaderClassName: PropTypes.string,

  /**
   * An optional className to apply to the content container of date picker.
   */
  pickerContentClassName: PropTypes.string,

  /**
   * An optional className to apply to the footer of date picker.
   */
  pickerFooterClassName: PropTypes.string,

  /**
   * An optional className to apply to the calendar container of date picker.
   */
  calendarClassName: PropTypes.string,

  /**
   * An optional className to apply to the year picker of date picker.
   */
  yearPickerClassName: PropTypes.string,

  /**
   * An optional style to apply to the input tag.
   */
  inputStyle: PropTypes.object,

  /**
   * An optional className to apply to the input tag.
   */
  inputClassName: PropTypes.string,

  /**
   * An optional style to apply to the text field's container.
   */
  textFieldStyle: PropTypes.object,

  /**
   * An optional className to apply to the text field's container.
   */
  textFieldClassName: PropTypes.string,

  /**
   * An optional icon to display with the date picker.
   *
   * @see {@link TextFields/TextField#leftIcon}
   */
  icon: PropTypes.node,

  /**
   * Boolean if the date picker is open by default.
   */
  defaultVisible: PropTypes.bool,

  /**
   * An optional label to be displayed in the date picker's text
   * field.
   */
  label: PropTypes.node,

  /**
   * An optional placeholder to be displayed in the date picker's text field.
   */
  placeholder: PropTypes.string,

  /**
   * The value of the date picker. This will make the date picker
   * be a controlled component. This value should either be a
   * formatted date string or a date object.
   */
  value: controlled(PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(Date)]), 'onChange', 'defaultValue'),

  /**
   * An optional default value to give for the date picker. This should
   * either be a formatted date string or a date object.
   */
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(Date)]),

  /**
   * An optional date to use when the calendar is opened for the first time.
   * If this is omitted, it will either be the `defaultValue`, `value`, or
   * today.
   */
  defaultCalendarDate: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(Date)]),

  /**
   * An optional function to call when the selected date is changed
   * by hitting the OK button. The newly formatted date string,
   * the new Date object, and the change event will be given.
   *
   * `onChange(dateString, dateObject, event)`.
   */
  onChange: PropTypes.func,

  /**
   * A function to format the dates since it should be formatted to the user's
   * locale. This _should_ be the `Intl.DateTimeFormat` function. You
   * can also create your own if you really wanted. Inadvisable though.
   *
   * See [intl-polyfill](https://github.com/andyearnshaw/Intl.js/) for more info.
   */
  DateTimeFormat: PropTypes.func.isRequired,

  /**
   * The locales to use for formatting the date. This will default to using
   * the user's language in the browser or `'en-US'` when server rendering.
   */
  locales: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).isRequired,

  /**
   * The label to use for the ok button on the date picker.
   */
  okLabel: PropTypes.node.isRequired,

  /**
   * Boolean if the ok button should be styled with the primary color.
   */
  okPrimary: PropTypes.bool,

  /**
   * The label to use for the cancel button on the date picker.
   */
  cancelLabel: PropTypes.node.isRequired,

  /**
   * Boolean if the cancel button should be styled with the primary color.
   */
  cancelPrimary: PropTypes.bool,

  /**
   * The initial mode to open the calendar in.
   */
  defaultCalendarMode: PropTypes.oneOf(['calendar', 'year']),

  /**
   * The icon to use to display the previous month icon in the calendar.
   */
  previousIcon: PropTypes.node,

  /**
   * The icon to use to display the next month icon in the calendar.
   */
  nextIcon: PropTypes.node,

  /**
   * An optional min date to use for the date picker. This will prevent
   * any dates before this time to be chosen.
   */
  minDate: PropTypes.instanceOf(Date),

  /**
   * An optional max date to use for the date picker. This will prevent
   * any dates after this time to be chosen.
   */
  maxDate: function maxDate(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    var err = PropTypes.instanceOf(Date).apply(undefined, [props, propName, component].concat(others));
    if (err || !props.minDate || !props[propName]) {
      return err;
    }

    var minDate = props.minDate,
        maxDate = props.maxDate;

    if (minDate > maxDate) {
      return new Error('The min date: \'' + minDate + '\' is greater than the max date: \'' + maxDate + '\'');
    }

    return null;
  },

  /**
   * Boolean if the date should automatically be selected when a user clicks
   * on a new date instead of making them hit the ok button.
   */
  autoOk: PropTypes.bool,

  /**
   * The number of years to display.
   */
  yearsDisplayed: PropTypes.number,

  /**
   * Boolean if the date picker should be displayed inline instead of in a
   * dialog.
   */
  inline: PropTypes.bool,

  /**
   * An optional force of the display mode of the date picker.
   * This _should_ not really be used since there are media queries
   * to use the correct mode based on device orientation.
   */
  displayMode: PropTypes.oneOf(['landscape', 'portrait']),

  /**
   * The DateTimeFormat options to apply to format the date.
   */
  formatOptions: PropTypes.shape({
    weekday: PropTypes.oneOf(['narrow', 'short', 'long']),
    era: PropTypes.oneOf(['narrow', 'short', 'long']),
    year: PropTypes.oneOf(['numeric', '2-digit']),
    month: PropTypes.oneOf(['numeric', '2-digit', 'narrow', 'short', 'long']),
    day: PropTypes.oneOf(['numeric', '2-digit']),
    hour: PropTypes.oneOf(['numeric', '2-digit']),
    minute: PropTypes.oneOf(['numeric', '2-digit']),
    second: PropTypes.oneOf(['numeric', '2-digit']),
    timeZoneName: PropTypes.oneOf(['short', 'long'])
  }),

  /**
   * Boolean if the text field for the Date Picker should be displayed as full width.
   */
  fullWidth: PropTypes.bool,

  /**
   * The direction that the text field divider expands from when the text field
   * in the date picker gains focus.
   */
  lineDirection: PropTypes.oneOf(['left', 'center', 'right']),

  /**
   * An optional boolean if the time picker is current visible by dialog or inline.
   * If this is set, the `onOpenToggle` function is required.
   */
  visible: controlled(PropTypes.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * An optional function to call when the date picker is opened in either a dialog, or
   * inline. The callback will include the next state.
   *
   * ```js
   * onVisibilityChange(!visible, e);
   * ```
   */
  onVisibilityChange: PropTypes.func,

  /**
   * Boolean if the time picker is disabled.
   */
  disabled: PropTypes.bool,

  /**
   * Boolean if the dialog should be able to close if a keyboard user presses the escape key.
   */
  closeOnEsc: PropTypes.bool,

  /**
   * Boolean if the inline time picker's visibility should be animated.
   */
  animateInline: PropTypes.bool,

  /**
   * Boolean if the time is required.
   *
   * @see {@link TextFields/TextField#required}
   */
  required: PropTypes.bool,

  /**
   * @see {@link TextFields/TextField#block}
   */
  block: TextField.propTypes.block,

  /**
   * @see {@link TextFields/TextField#paddedBlock}
   */
  paddedBlock: TextField.propTypes.paddedBlock,

  /**
   * @see {@link TextFields/TextField#active}
   */
  active: TextField.propTypes.active,

  /**
   * @see {@link TextFields/TextField#error}
   */
  error: TextField.propTypes.error,

  /**
   * @see {@link TextFields/TextField#floating}
   */
  floating: TextField.propTypes.floating,

  /**
   * @see {@link TextFields/TextField#leftIconStateful}
   */
  leftIconStateful: TextField.propTypes.leftIconStateful,

  /**
   * @see {@link TextFields/TextField#rightIcon}
   */
  rightIcon: TextField.propTypes.rightIcon,

  /**
   * @see {@link TextFields/TextField#rightIconStateful}
   */
  rightIconStateful: TextField.propTypes.rightIconStateful,

  /**
   * @see {@link TextFields/TextField#customSize}
   */
  customSize: TextField.propTypes.customSize,

  /**
   * @see {@link TextFields/TextField#errorText}
   */
  errorText: TextField.propTypes.errorText,

  /**
   * @see {@link TextFields/TextField#helpText}
   */
  helpText: TextField.propTypes.helpText,

  /**
   * @see {@link TextFields/TextField#helpOnFocus}
   */
  helpOnFocus: TextField.propTypes.helpOnFocus,

  /**
   * @see {@link TextFields/TextField#inlineIndicator}
   */
  inlineIndicator: TextField.propTypes.inlineIndicator,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the dialog.
   *
   * @see {@link Helpers/Portal}
   */
  portal: PropTypes.bool,

  /**
   * An optional DOM Node to render the dialog into. The default is to render as the first child
   * in the `body`.
   */
  renderNode: PropTypes.object,

  /**
   * Boolean if the DatePicker should be read only. This will prevent the user from opening the picker
   * and only display the current date in the text field.
   */
  readOnly: PropTypes.bool,

  /**
   * The first day of week: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
   */
  firstDayOfWeek: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6]),

  /**
   * True if weekends are to be greyed out.
   */
  disableWeekEnds: PropTypes.bool,

  /**
   * True if dates from adjacent months should be shown in calendar.
   */
  showAllDays: PropTypes.bool,

  /**
   * Boolean if the dates from adjacent months should be disabled. This will only
   * do something if the `showAllDays` prop is enabled as well.
   *
   * This is really only helpful if youd like the other days to appear, but not be
   * clickable until the user switches to that month.
   *
   * @see {@link #showAllDays}
   */
  disableOuterDates: PropTypes.bool,

  /**
   * An optional className to apply to a date in calendar.
   */
  calendarDateClassName: PropTypes.string,

  /**
   * An optional className to apply to a date from an adjacent month in calendar. This will be applied
   * along with the `calendarDateClassName`.
   *
   * @see {@link #showAllDays}
   * @see {@link #calendarDateClassName}
   */
  calendarOuterDateClassName: PropTypes.string,

  /**
   * An optional function to provide class for each date in calendar.
   *
   * ```js
   * getDateClassName(date:Date, day:number): string;
   * ```
   */
  getDateClassName: PropTypes.func,

  /**
   * An optional function to render each date component.
   *
   * ```js
   * dateRenderer(date:Date, day:number): React.Component;
   * ```
   */
  dateRenderer: PropTypes.func,

  /**
   * An optional callback triggered on previous month click.
   *
   * ```js
   * onPreviousMonth(firstDayInMonth:Date);
   * ```
   */
  onPreviousMonth: PropTypes.func,

  /**
   * An optional callback triggered on next month click.
   *
   * ```js
   * onNextMonth(firstDayInMonth:Date);
   * ```
   */
  onNextMonth: PropTypes.func,

  /**
   * An optional callback triggered on year selection.
   *
   * ```js
   * onYearSelected(firstDayInYear:Date);
   * ```
   */
  onYearSelected: PropTypes.func,

  /**
   * An optional className to apply to the title in calendar header.
   */
  calendarTitleClassName: PropTypes.string,

  /**
   * The DateTimeFormat options to apply to format the title in calendar header.
   */
  calendarTitleFormat: PropTypes.shape({
    era: PropTypes.oneOf(['narrow', 'short', 'long']),
    year: PropTypes.oneOf(['numeric', '2-digit']),
    month: PropTypes.oneOf(['numeric', '2-digit', 'narrow', 'short', 'long'])
  }),

  /**
   * An optional className to apply to a weekday in calendar header.
   */
  calendarWeekdayClassName: PropTypes.string,

  /**
   * The DateTimeFormat option to apply to format a weekday in calendar header.
   */
  calendarWeekdayFormat: PropTypes.oneOf(['narrow', 'short', 'long']),

  /**
   * @see {@link Dialogs/DialogContainer#disableScrollLocking}
   */
  disableScrollLocking: PropTypes.bool,

  /**
   * Boolean if the dialog should be rendered as the last child of the `renderNode` or `body` instead
   * of the first.
   */
  lastChild: PropTypes.bool,

  /**
   * True if the datepicker should swap to calendar mode automatically after a year is picked
   * while in `year` mode.
   */
  closeYearOnSelect: PropTypes.bool,

  previousIconChildren: deprecated(PropTypes.node, 'Use the `previousIcon` prop instead'),
  previousIconClassName: deprecated(PropTypes.string, 'Use the `previousIcon` prop instead'),
  nextIconChildren: deprecated(PropTypes.node, 'use the `nextIcon` prop instead'),
  nextIconClassName: deprecated(PropTypes.string, 'Use the `nextIcon` prop instead'),
  adjustMinWidth: deprecated(PropTypes.bool, 'No longer valid for a text field'),
  isOpen: deprecated(PropTypes.bool, 'Use `visible` instead'),
  initiallyOpen: deprecated(PropTypes.bool, 'Use `defaultVisible` instead'),
  initialCalendarDate: deprecated(PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(Date)]), 'Use `defaultCalendarDate` instead'),
  initialCalendarMode: deprecated(PropTypes.oneOf(['calendar', 'year']), 'Use `defaultCalendarMode` instead'),
  initialYearsDisplayed: deprecated(PropTypes.number, 'Use `yearsDisplayed` instead. I have not implemented infinite loading years')
};
DatePickerContainer.defaultProps = {
  animateInline: true,
  previousIcon: React.createElement(
    FontIcon,
    null,
    'chevron_left'
  ),
  nextIcon: React.createElement(
    FontIcon,
    null,
    'chevron_right'
  ),
  autoOk: false,
  icon: React.createElement(
    FontIcon,
    null,
    'date_range'
  ),
  yearsDisplayed: 100,
  defaultCalendarMode: 'calendar',
  DateTimeFormat: DateTimeFormat, // eslint-disable-line object-shorthand
  locales: typeof window !== 'undefined' ? window.navigator.userLanguage || window.navigator.language : 'en-US',
  okLabel: 'Ok',
  okPrimary: true,
  cancelLabel: 'Cancel',
  cancelPrimary: true,
  closeOnEsc: true,
  closeYearOnSelect: false,
  disableScrollLocking: false,
  'aria-label': 'Pick a date'
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setContainer = function (container) {
    _this2._container = container;
  };

  this._closeOnEsc = function (e) {
    if ((e.which || e.keyCode) === ESC) {
      _this2._handleCancelClick(e);
    }
  };

  this._handleOutsideClick = function (e) {
    if (_this2._container && !_this2._container.contains(e.target)) {
      _this2._handleCancelClick(e);
    }
  };

  this._toggleOpen = function (e) {
    if (_this2.props.disabled || _this2.props.readOnly) {
      return;
    }

    var visible = !(typeof _this2.props.isOpen !== 'undefined' ? _this2.props.isOpen : getField(_this2.props, _this2.state, 'visible'));

    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(visible, e);
    }

    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      _this2.setState({ visible: visible });
    }
  };

  this._handleKeyDown = function (e) {
    handleKeyboardAccessibility(e, _this2._toggleOpen, true, true);

    if ((e.which || e.keyCode) === TAB && _this2.state.active) {
      _this2.setState({ active: false });
    }
  };

  this._handleOkClick = function (e) {
    var _props3 = _this2.props,
        DateTimeFormat = _props3.DateTimeFormat,
        locales = _props3.locales,
        onChange = _props3.onChange,
        formatOptions = _props3.formatOptions,
        onVisibilityChange = _props3.onVisibilityChange;

    var value = DateTimeFormat(locales, formatOptions).format(_this2.state.calendarTempDate);
    if (onChange) {
      onChange(value, new Date(_this2.state.calendarTempDate), e);
    }

    if (onVisibilityChange) {
      onVisibilityChange(false, e);
    }

    var state = void 0;
    if (typeof _this2.props.value === 'undefined') {
      state = { value: value };
    }

    if (typeof _this2.props.visible === 'undefined' && typeof _this2.props.isOpen === 'undefined') {
      state = state || {};
      state.visible = false;
    }

    if (state) {
      _this2.setState(state);
    }
  };

  this._handleCancelClick = function (e) {
    var state = { calendarTempDate: _this2.state.calendarDate };
    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.isOpen === 'undefined') {
      state.visible = false;
    }

    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(false, e);
    }

    _this2.setState(state);
  };

  this._changeCalendarMode = function (calendarMode) {
    if (_this2.state.calendarMode === calendarMode) {
      return;
    }

    _this2.setState({ calendarMode: calendarMode });
  };

  this._previousMonth = function () {
    var calendarDate = addDate(_this2.state.calendarDate, -1, 'M');
    _this2.setState({ calendarDate: calendarDate });

    if (_this2.props.onPreviousMonth) {
      _this2.props.onPreviousMonth(calendarDate);
    }
  };

  this._nextMonth = function () {
    var calendarDate = addDate(_this2.state.calendarDate, 1, 'M');
    _this2.setState({ calendarDate: calendarDate });

    if (_this2.props.onNextMonth) {
      _this2.props.onNextMonth(calendarDate);
    }
  };

  this._setCalendarTempDate = function (calendarTempDate) {
    var _props4 = _this2.props,
        autoOk = _props4.autoOk,
        DateTimeFormat = _props4.DateTimeFormat,
        locales = _props4.locales,
        onChange = _props4.onChange,
        formatOptions = _props4.formatOptions;


    var state = { calendarTempDate: calendarTempDate };
    if (autoOk) {
      var value = DateTimeFormat(locales, formatOptions).format(calendarTempDate);
      if (onChange) {
        onChange(value, new Date(calendarTempDate));
      }

      if (typeof _this2.props.value === 'undefined') {
        state.value = value;
      }

      _this2._timeout = setTimeout(function () {
        _this2._timeout = null;

        if (_this2.props.onVisibilityChange) {
          _this2.props.onVisibilityChange(false);
        }

        if (typeof _this2.props.visible === 'undefined' && typeof _this2.props.isOpen === 'undefined') {
          _this2.setState({ visible: false });
        }
      });
    }
    _this2.setState(state);
  };

  this._setCalendarTempYear = function (year) {
    var _state = _this2.state,
        calendarTempDate = _state.calendarTempDate,
        calendarDate = _state.calendarDate;

    if (calendarTempDate.getFullYear() === year) {
      return;
    }

    var _props5 = _this2.props,
        minDate = _props5.minDate,
        maxDate = _props5.maxDate;

    var nextDate = new Date(calendarDate.setFullYear(year));
    var nextTemp = new Date(calendarTempDate.setFullYear(year));

    if (minDate && nextTemp < minDate) {
      nextDate = new Date(minDate);
      nextTemp = new Date(minDate);
    }

    if (maxDate && nextTemp > maxDate) {
      nextDate = new Date(maxDate);
      nextTemp = new Date(maxDate);
    }

    if (_this2.props.onYearSelected) {
      _this2.props.onYearSelected(nextDate);
    }

    _this2.setState({
      calendarDate: nextDate,
      calendarTempDate: nextTemp
    });

    if (_this2.props.closeYearOnSelect) {
      _this2._changeCalendarMode('calendar');
    }
  };
};

export default DatePickerContainer;