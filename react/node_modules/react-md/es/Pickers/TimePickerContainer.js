var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-shadow */
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import isRequiredForA11y from 'react-prop-types/lib/isRequiredForA11y';
import deprecated from 'react-prop-types/lib/deprecated';

import { ESC, TAB } from '../constants/keyCodes';
import getField from '../utils/getField';
import handleWindowClickListeners from '../utils/EventUtils/handleWindowClickListeners';
import handleKeyboardAccessibility from '../utils/EventUtils/handleKeyboardAccessibility';
import controlled from '../utils/PropTypes/controlled';
import DateTimeFormat from '../utils/DateUtils/DateTimeFormat';
import formatTime from '../utils/DateUtils/formatTime';
import extractTimeParts from '../utils/DateUtils/extractTimeParts';
import Dialog from '../Dialogs/DialogContainer';
import FontIcon from '../FontIcons/FontIcon';
import TextField from '../TextFields/TextField';
import Collapse from '../Helpers/Collapse';
import TimePicker from './TimePicker';

/**
 * The `TimePickerContainer` component is a wrapper for the main `TimePicker` component
 * to manage the state and _logic_ for rendering the `TimePicker`. This component will
 * either render inline or in a `Dialog` depending if the `inline` prop is set
 * to `true`.
 *
 * NOTE: This component is actually exported as `TimePicker` when using the `import { member }` syntax.
 * The following two lines are equivalent:
 *
 * ```js
 * import { TimePicker } from 'react-md/lib/Pickers';
 * import TimePicker from 'react-md/lib/Pickers/TimePickerContainer';
 * ```
 */

var TimePickerContainer = function (_PureComponent) {
  _inherits(TimePickerContainer, _PureComponent);

  function TimePickerContainer(props) {
    _classCallCheck(this, TimePickerContainer);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _initialiseProps.call(_this);

    var initialDate = void 0;
    if (props.defaultValue) {
      initialDate = new Date(props.defaultValue);
    } else if (props.value) {
      initialDate = new Date(props.value);
    } else {
      initialDate = new Date();
    }

    var visible = typeof props.initiallyOpen !== 'undefined' ? props.initiallyOpen : !!props.defaultVisible;

    _this.state = _extends({
      visible: visible
    }, _this._getTimeParts(initialDate, props), {
      value: props.defaultValue,
      time: initialDate,
      timeMode: props.initialTimeMode || props.defaultTimeMode,
      tempTime: initialDate
    });
    return _this;
  }

  TimePickerContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.value !== nextProps.value) {
      var time = nextProps.value || new Date();
      this.setState(_extends({ tempTime: time }, this._getTimeParts(time, nextProps)));
    }
  };

  TimePickerContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var _props = this.props,
        inline = _props.inline,
        isOpen = _props.isOpen;

    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(this.props, this.state, 'visible');
    var pVisible = typeof prevProps.isOpen !== 'undefined' ? prevProps.isOpen : getField(prevProps, prevState, 'visible');

    if (visible === pVisible) {
      return;
    }

    if (visible) {
      if (inline) {
        handleWindowClickListeners(this._handleOutsideClick, true);
        window.addEventListener('keydown', this._closeOnEsc);
      }
    } else if (inline) {
      handleWindowClickListeners(this._handleOutsideClick, false);
      window.removeEventListener('keydown', this._closeOnEsc);
    }
  };

  TimePickerContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    var visible = typeof this.props.isOpen !== 'undefined' ? this.props.isOpen : getField(this.props, this.state, 'visible');
    if (visible && this.props.inline) {
      handleWindowClickListeners(this._handleOutsideClick, false);
      window.removeEventListener('keydown', this._closeOnEsc);
    }
  };

  TimePickerContainer.prototype._getTimeParts = function _getTimeParts(date, props) {
    return extractTimeParts(props.DateTimeFormat, props.locales, props.showSeconds, date);
  };

  TimePickerContainer.prototype._getTextFieldValue = function _getTextFieldValue(props, state) {
    var DateTimeFormat = props.DateTimeFormat,
        locales = props.locales,
        showSeconds = props.showSeconds;

    var value = getField(props, state, 'value');
    if (!value) {
      return '';
    } else if (value instanceof Date) {
      return formatTime(DateTimeFormat, locales, showSeconds, value);
    } else {
      // currently don't support value of string
      return value;
    }
  };

  TimePickerContainer.prototype.render = function render() {
    var _state = this.state,
        timeMode = _state.timeMode,
        tempTime = _state.tempTime,
        hours = _state.hours,
        minutes = _state.minutes,
        seconds = _state.seconds,
        timePeriod = _state.timePeriod;

    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        pickerStyle = _props2.pickerStyle,
        pickerClassName = _props2.pickerClassName,
        inputStyle = _props2.inputStyle,
        inputClassName = _props2.inputClassName,
        textFieldStyle = _props2.textFieldStyle,
        textFieldClassName = _props2.textFieldClassName,
        id = _props2.id,
        disabled = _props2.disabled,
        label = _props2.label,
        placeholder = _props2.placeholder,
        icon = _props2.icon,
        inline = _props2.inline,
        displayMode = _props2.displayMode,
        fullWidth = _props2.fullWidth,
        lineDirection = _props2.lineDirection,
        closeOnEsc = _props2.closeOnEsc,
        hoverMode = _props2.hoverMode,
        showSeconds = _props2.showSeconds,
        portal = _props2.portal,
        renderNode = _props2.renderNode,
        lastChild = _props2.lastChild,
        animateInline = _props2.animateInline,
        block = _props2.block,
        paddedBlock = _props2.paddedBlock,
        active = _props2.active,
        error = _props2.error,
        floating = _props2.floating,
        required = _props2.required,
        leftIconStateful = _props2.leftIconStateful,
        rightIcon = _props2.rightIcon,
        rightIconStateful = _props2.rightIconStateful,
        customSize = _props2.customSize,
        errorText = _props2.errorText,
        helpText = _props2.helpText,
        helpOnFocus = _props2.helpOnFocus,
        inlineIndicator = _props2.inlineIndicator,
        disableScrollLocking = _props2.disableScrollLocking,
        ariaLabel = _props2['aria-label'],
        propValue = _props2.value,
        propVisible = _props2.visible,
        readOnly = _props2.readOnly,
        defaultValue = _props2.defaultValue,
        defaultVisible = _props2.defaultVisible,
        defaultTimeMode = _props2.defaultTimeMode,
        onVisibilityChange = _props2.onVisibilityChange,
        isOpen = _props2.isOpen,
        initialTimeMode = _props2.initialTimeMode,
        initiallyOpen = _props2.initiallyOpen,
        props = _objectWithoutProperties(_props2, ['style', 'className', 'pickerStyle', 'pickerClassName', 'inputStyle', 'inputClassName', 'textFieldStyle', 'textFieldClassName', 'id', 'disabled', 'label', 'placeholder', 'icon', 'inline', 'displayMode', 'fullWidth', 'lineDirection', 'closeOnEsc', 'hoverMode', 'showSeconds', 'portal', 'renderNode', 'lastChild', 'animateInline', 'block', 'paddedBlock', 'active', 'error', 'floating', 'required', 'leftIconStateful', 'rightIcon', 'rightIconStateful', 'customSize', 'errorText', 'helpText', 'helpOnFocus', 'inlineIndicator', 'disableScrollLocking', 'aria-label', 'value', 'visible', 'readOnly', 'defaultValue', 'defaultVisible', 'defaultTimeMode', 'onVisibilityChange', 'isOpen', 'initialTimeMode', 'initiallyOpen']);

    var visible = typeof this.props.isOpen !== 'undefined' ? this.props.isOpen : getField(this.props, this.state, 'visible');

    var picker = React.createElement(TimePicker, _extends({}, props, {
      inline: inline,
      icon: !!icon,
      tempTime: tempTime,
      timeMode: timeMode,
      seconds: seconds,
      hours: hours,
      minutes: minutes,
      timePeriod: timePeriod,
      style: pickerStyle,
      className: pickerClassName,
      displayMode: displayMode,
      onOkClick: this._handleOkClick,
      onCancelClick: this._handleCancelClick,
      setTimeMode: this._setTimeMode,
      setTempTime: this._setTempTime,
      hoverMode: hoverMode,
      showSeconds: showSeconds
    }));

    var content = void 0;
    if (inline) {
      content = React.createElement(
        Collapse,
        { collapsed: !visible, animate: animateInline },
        picker
      );
    } else {
      content = React.createElement(
        Dialog,
        {
          id: id + '-dialog',
          visible: visible,
          onHide: this._handleCancelClick,
          dialogClassName: 'md-dialog--picker',
          contentClassName: 'md-dialog-content--picker',
          'aria-label': ariaLabel,
          closeOnEsc: closeOnEsc,
          portal: portal,
          lastChild: lastChild,
          renderNode: renderNode,
          focusOnMount: false,
          disableScrollLocking: disableScrollLocking
        },
        picker
      );
    }

    return React.createElement(
      'div',
      { style: style, className: cn('md-picker-container', className), ref: this._setContainer },
      React.createElement(TextField, {
        id: id,
        style: textFieldStyle,
        className: cn({ 'md-pointer--hover': !disabled }, textFieldClassName),
        inputStyle: inputStyle,
        inputClassName: cn({ 'md-pointer--hover': !disabled }, inputClassName),
        active: active || visible,
        error: error,
        floating: floating || visible,
        required: required,
        disabled: disabled,
        leftIcon: icon,
        leftIconStateful: leftIconStateful,
        rightIcon: rightIcon,
        rightIconStateful: rightIconStateful,
        inlineIndicator: inlineIndicator,
        block: block,
        paddedBlock: paddedBlock,
        fullWidth: fullWidth,
        lineDirection: lineDirection,
        customSize: customSize,
        helpText: helpText,
        helpOnFocus: helpOnFocus,
        errorText: errorText,
        label: label,
        placeholder: placeholder,
        onClick: this._toggleOpen,
        onKeyDown: this._handleKeyDown,
        value: this._getTextFieldValue(this.props, this.state),
        readOnly: true
      }),
      content
    );
  };

  return TimePickerContainer;
}(PureComponent);

TimePickerContainer.propTypes = {
  /**
   * An id for the text field in the time picker. This is require for a11y.
   */
  id: isRequiredForA11y(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),

  /**
   * An aria-label to apply to the dialog when it has been opened. This is required for
   * a11y.
   */
  'aria-label': isRequiredForA11y(PropTypes.string),

  /**
   * An optional style to apply to the time picker's container.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the time picker's container.
   */
  className: PropTypes.string,

  /**
   * An optional style to apply to the time picker.
   */
  pickerStyle: PropTypes.object,

  /**
   * An optional className to apply to the time picker.
   */
  pickerClassName: PropTypes.string,

  /**
   * An optional style to apply to the input tag.
   */
  inputStyle: PropTypes.object,

  /**
   * An optional className to apply to the input tag.
   */
  inputClassName: PropTypes.string,

  /**
   * An optional style to apply to the text field's container.
   */
  textFieldStyle: PropTypes.object,

  /**
   * An optional className to apply to the text field's container.
   */
  textFieldClassName: PropTypes.string,

  /**
   * An optional icon to display with the time picker.
   *
   * @see {@link TextFields/TextField#leftIcon}
   */
  icon: PropTypes.node,

  /**
   * Boolean if the time picker is open by default.
   */
  defaultVisible: PropTypes.bool,

  /**
   * An optional label to be displayed in the time picker's text
   * field.
   */
  label: PropTypes.node,

  /**
   * An optional placeholder to be displayed in the time picker's text field.
   */
  placeholder: PropTypes.string,

  /**
   * The value of the time picker. This will make the time picker
   * be a controlled component.
   */
  value: controlled(PropTypes.instanceOf(Date), 'onChange', 'defaultValue'),

  /**
   * An optional function to call when the selected date is changed
   * by hitting the OK button. The newly formatted time string,
   * the new Date object, and the change event will be given.
   *
   * `onChange(timeString, dateObject, event)`.
   */
  onChange: PropTypes.func,

  /**
   * An optional default value to give for the year picker.
   */
  defaultValue: PropTypes.instanceOf(Date),

  /**
   * A function to format the dates since it should be formatted to the user's
   * locale. This _should_ be the `Intl.DateTimeFormat` function. You
   * can also create your own if you really wanted. Inadvisable though.
   *
   * See [intl-polyfill](https://github.com/andyearnshaw/Intl.js/) for more info.
   */
  DateTimeFormat: PropTypes.func.isRequired,

  /**
   * The locales to use for formatting the date. This will default to using
   * the user's language in the browser or `'en-US'` when server rendering.
   */
  locales: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).isRequired,

  /**
   * The label to use for the ok button on the year picker.
   */
  okLabel: PropTypes.node.isRequired,

  /**
   * Boolean if the ok button should be styled with the primary color.
   */
  okPrimary: PropTypes.bool,

  /**
   * The label to use for the cancel button on the year picker.
   */
  cancelLabel: PropTypes.node.isRequired,

  /**
   * Boolean if the cancel button should be styled with the primary color.
   */
  cancelPrimary: PropTypes.bool,

  /**
   * The default mode to open the time picker in.
   */
  defaultTimeMode: PropTypes.oneOf(['hour', 'minute', 'second']),

  /**
   * Boolean if the date should automatically be selected when a user clicks
   * on a new date instead of making them hit the ok button.
   */
  autoOk: PropTypes.bool,

  /**
   * Boolean if the date picker should be displayed inline instead of in a
   * dialog.
   */
  inline: PropTypes.bool,

  /**
   * An optional force of the display mode of the date picker.
   * This _should_ not really be used since there are media queries
   * to use the correct mode based on device orientation.
   */
  displayMode: PropTypes.oneOf(['landscape', 'portrait']),

  /**
   * Boolean if the text field for the Time Picker should be displayed as full width.
   */
  fullWidth: PropTypes.bool,

  /**
   * The direction that the text field divider expands from when the text field
   * in the date picker gains focus.
   */
  lineDirection: PropTypes.oneOf(['left', 'center', 'right']),

  /**
   * An optional boolean if the time picker is current visible by dialog or inline.
   * If this is set, the `onVisibilityChange` function is required.
   */
  visible: controlled(PropTypes.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * An optional function to call when the date picker is opened in either a dialog, or
   * inline. The callback will include the next state.
   *
   * ```js
   * onVisibilityChange(!visible, e);
   * ```
   */
  onVisibilityChange: PropTypes.func,

  /**
   * Boolean if the time picker is disabled.
   */
  disabled: PropTypes.bool,

  /**
   * Boolean if the dialog should be able to close if a keyboard user presses the escape key.
   */
  closeOnEsc: PropTypes.bool,

  /**
   * If true the hover mode of the Time Picker is activated.
   * In hover mode no clicks are required to start selecting an hour
   * and the time mode switches automatically when a time was chosen.
   * When a minute is selected the chosen time is applied automatically.
   */
  hoverMode: PropTypes.bool,

  /**
   * If true seconds will be selectable in the Time Picker.
   */
  showSeconds: PropTypes.bool,

  /**
   * Boolean if the inline time picker's visibility should be animated.
   */
  animateInline: PropTypes.bool,

  /**
   * Boolean if the time is required.
   *
   * @see {@link TextFields/TextField#required}
   */
  required: PropTypes.bool,

  /**
   * @see {@link TextFields/TextField#block}
   */
  block: TextField.propTypes.block,

  /**
   * @see {@link TextFields/TextField#paddedBlock}
   */
  paddedBlock: TextField.propTypes.paddedBlock,

  /**
   * @see {@link TextFields/TextField#active}
   */
  active: TextField.propTypes.active,

  /**
   * @see {@link TextFields/TextField#error}
   */
  error: TextField.propTypes.error,

  /**
   * @see {@link TextFields/TextField#floating}
   */
  floating: TextField.propTypes.floating,

  /**
   * @see {@link TextFields/TextField#leftIconStateful}
   */
  leftIconStateful: TextField.propTypes.leftIconStateful,

  /**
   * @see {@link TextFields/TextField#rightIcon}
   */
  rightIcon: TextField.propTypes.rightIcon,

  /**
   * @see {@link TextFields/TextField#rightIconStateful}
   */
  rightIconStateful: TextField.propTypes.rightIconStateful,

  /**
   * @see {@link TextFields/TextField#customSize}
   */
  customSize: TextField.propTypes.customSize,

  /**
   * @see {@link TextFields/TextField#errorText}
   */
  errorText: TextField.propTypes.errorText,

  /**
   * @see {@link TextFields/TextField#helpText}
   */
  helpText: TextField.propTypes.helpText,

  /**
   * @see {@link TextFields/TextField#helpOnFocus}
   */
  helpOnFocus: TextField.propTypes.helpOnFocus,

  /**
   * @see {@link TextFields/TextField#inlineIndicator}
   */
  inlineIndicator: TextField.propTypes.inlineIndicator,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the dialog.
   *
   * @see {@link Helpers/Portal}
   */
  portal: PropTypes.bool,

  /**
   * An optional DOM Node to render the dialog into. The default is to render as the first child
   * in the `body`.
   */
  renderNode: PropTypes.object,

  /**
   * Boolean if the dialog should be rendered as the last child of the `renderNode` or `body` instead
   * of the first.
   */
  lastChild: PropTypes.bool,

  /**
   * @see {@link Dialogs/DialogContainer#disableScrollLocking}
   */
  disableScrollLocking: PropTypes.bool,

  /**
   * Boolean if the TimePicker should be read only. This will prevent the user from opening the picker
   * and only display the current date in the text field.
   */
  readOnly: PropTypes.bool,

  isOpen: deprecated(PropTypes.bool, 'Use `visible` instead'),
  initiallyOpen: deprecated(PropTypes.bool, 'Use `defaultVisible` instead'),
  initialTimeMode: deprecated(PropTypes.oneOf(['hour', 'minute']), 'Use `defaultTimeMode` instead')
};
TimePickerContainer.defaultProps = {
  animateInline: true,
  defaultTimeMode: 'hour',
  icon: React.createElement(
    FontIcon,
    null,
    'access_time'
  ),
  DateTimeFormat: DateTimeFormat, // eslint-disable-line object-shorthand
  locales: typeof window !== 'undefined' ? window.navigator.userLanguage || window.navigator.language : 'en-US',
  okLabel: 'Ok',
  okPrimary: true,
  cancelLabel: 'Cancel',
  cancelPrimary: true,
  closeOnEsc: true,
  disableScrollLocking: false,
  'aria-label': 'Select a time',
  hoverMode: false,
  showSeconds: false
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setContainer = function (container) {
    _this2._container = container;
  };

  this._closeOnEsc = function (e) {
    if ((e.which || e.keyCode) === ESC) {
      _this2._handleCancelClick(e);
    }
  };

  this._handleOutsideClick = function (e) {
    if (_this2._container && !_this2._container.contains(e.target)) {
      _this2._handleCancelClick(e);
    }
  };

  this._toggleOpen = function (e) {
    if (_this2.props.disabled || _this2.props.readOnly) {
      return;
    }

    var visible = !(typeof _this2.props.isOpen !== 'undefined' ? _this2.props.isOpen : getField(_this2.props, _this2.state, 'visible'));

    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(visible, e);
    }

    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      var hoverMode = _this2.props.hoverMode;


      if (hoverMode) {
        _this2._setTimeMode('hour');
      }

      _this2.setState({ visible: visible });
    }
  };

  this._setTimeMode = function (timeMode) {
    if (_this2.state.timeMode === timeMode) {
      return;
    }

    _this2.setState({ timeMode: timeMode });
  };

  this._setTempTime = function (time) {
    if (_this2.state.tempTime === time) {
      return;
    }

    _this2.setState(_extends({ tempTime: time }, _this2._getTimeParts(time, _this2.props)));
  };

  this._handleKeyDown = function (e) {
    handleKeyboardAccessibility(e, _this2._toggleOpen, true, true);

    if ((e.which || e.keyCode) === TAB && _this2.state.active) {
      _this2.setState({ active: false });
    }
  };

  this._handleOkClick = function (e) {
    var _props3 = _this2.props,
        onVisibilityChange = _props3.onVisibilityChange,
        onChange = _props3.onChange,
        DateTimeFormat = _props3.DateTimeFormat,
        locales = _props3.locales,
        showSeconds = _props3.showSeconds;

    var value = new Date(_this2.state.tempTime);
    if (onChange) {
      onChange(formatTime(DateTimeFormat, locales, showSeconds, value), value, e);
    }

    if (onVisibilityChange) {
      onVisibilityChange(false, e);
    }

    var state = _extends({ time: value }, _this2._getTimeParts(value, _this2.props));
    if (typeof _this2.props.value === 'undefined') {
      state.value = value;
    }

    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      state.visible = false;
    }

    _this2.setState(state);
  };

  this._handleCancelClick = function (e) {
    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(false, e);
    }

    var state = void 0;
    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      state = { visible: false };
    }

    var value = getField(_this2.props, _this2.state, 'value');
    if (value) {
      state = _extends({}, state, _this2._getTimeParts(value, _this2.props));
      state.tempTime = _this2.state.time;
    }

    if (state) {
      _this2.setState(state);
    }
  };
};

export default TimePickerContainer;