function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';

/**
 * The `ClockHand` component is just used to display the hand of the clock
 * and a ball to surround the selected time.
 */

var ClockHand = function (_PureComponent) {
  _inherits(ClockHand, _PureComponent);

  function ClockHand(props) {
    _classCallCheck(this, ClockHand);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = { active: false };
    return _this;
  }

  ClockHand.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (this.props.minutes !== nextProps.minutes) {
      if (this.state.timeout) {
        clearTimeout(this.state.timeout);
      }

      this.setState({
        active: true,
        timeout: setTimeout(function () {
          return _this2.setState({ active: false, timeout: null });
        }, 150)
      });
    }
  };

  ClockHand.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.state.timeout) {
      clearTimeout(this.state.timeout);
    }
  };

  ClockHand.prototype._calcCurrentDegrees = function _calcCurrentDegrees(_ref) {
    var time = _ref.time,
        minutes = _ref.minutes;

    var timeAt0Deg = minutes ? 15 : 3;
    var sectors = minutes ? 60 : 12;

    return (time % sectors - timeAt0Deg) * (360 / sectors);
  };

  ClockHand.prototype.render = function render() {
    var _props = this.props,
        coords = _props.coords,
        time = _props.time,
        minutes = _props.minutes;


    var degrees = this._calcCurrentDegrees(this.props);
    var invisibleMinute = false;
    if (minutes) {
      invisibleMinute = degrees % (360 / 12) !== 0;
    }

    var rotateTransform = 'rotate3d(0, 0, 1, ' + degrees + 'deg)';
    return React.createElement('div', {
      className: cn('md-clock-hand md-background--primary', {
        'md-clock-hand--active': this.state.active,
        'md-clock-hand--minute-hover': invisibleMinute,
        'md-clock-hand--inner': !minutes && (time > 12 || time === 0)
      }),
      style: {
        left: coords,
        top: coords,
        WebkitTransform: rotateTransform,
        MozTransform: rotateTransform,
        msTransform: rotateTransform,
        transform: rotateTransform
      }
    });
  };

  return ClockHand;
}(PureComponent);

ClockHand.propTypes = {
  /**
   * This is the x and y coordinate to use for the center of the `ClockFace`.
   * This should really be whatever the radius of the `ClockFace` is.
   */
  coords: PropTypes.number,

  /**
   * The current time of the clock.
   */
  time: PropTypes.number.isRequired,

  /**
   * Boolean if the clock is displaying minutes instead of hours.
   */
  minutes: PropTypes.bool.isRequired
};
export default ClockHand;