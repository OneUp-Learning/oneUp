function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';

import isValidClick from '../utils/EventUtils/isValidClick';
import captureNextEvent from '../utils/EventUtils/captureNextEvent';
import { addTouchEvent, removeTouchEvent } from '../utils/EventUtils/touches';
import calcTimeFromPoint from '../utils/NumberUtils/calcTimeFromPoint';
import calcPageOffset from '../utils/Positioning/calcPageOffset';
import ResizeObserver from '../Helpers/ResizeObserver';

import ClockTime from './ClockTime';
import ClockHand from './ClockHand';

/**
 * The `ClockFace` component is used for rendering all the clock's times
 * and the clock hand.
 */

var ClockFace = function (_PureComponent) {
  _inherits(ClockFace, _PureComponent);

  function ClockFace(props) {
    _classCallCheck(this, ClockFace);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setFace = function (face) {
      _this._face = face;
      _this._setPositioning();
    };

    _this._setPositioning = function () {
      if (!_this._face) {
        return;
      }

      var radius = _this._face.offsetWidth / 2;
      var offset = calcPageOffset(_this._face);
      _this._center = { x: offset.left + radius, y: offset.top + radius };
      _this._left = offset.left;
      _this._top = offset.top;

      if (_this.state.radius !== radius) {
        _this.setState({ radius: radius });
      }
    };

    _this._handleMouseEnter = function () {
      var hoverMode = _this.props.hoverMode;


      if (hoverMode) {
        _this._enableMouseMoving();
      }
    };

    _this._handleMouseLeave = function () {
      var hoverMode = _this.props.hoverMode;


      if (hoverMode) {
        _this._disableMouseMoving();
      }
    };

    _this._handleMouseDown = function (e) {
      if (!isValidClick(e)) {
        return;
      }

      var hoverMode = _this.props.hoverMode;


      if (!hoverMode) {
        _this._enableMouseMoving();
      }
    };

    _this._handleMouseMove = function (e) {
      if (!_this.state.moving) {
        return;
      }

      e.preventDefault();
      _this._calcNewTime(e);
    };

    _this._handleMouseUp = function (e) {
      if (!isValidClick(e)) {
        return;
      }

      var _this$props = _this.props,
          onTimeChosen = _this$props.onTimeChosen,
          hoverMode = _this$props.hoverMode;


      if (_this._face) {
        if (_this._face.contains(e.target)) {
          onTimeChosen();
          _this._calcNewTime(e);
        } else {
          captureNextEvent('click');
        }
      }

      if (!hoverMode) {
        _this._disableMouseMoving();
      }
    };

    _this._handleTouchStart = function () {
      captureNextEvent('mousedown');

      addTouchEvent(window, 'move', _this._handleTouchMove);
      addTouchEvent(window, 'end', _this._handleTouchEnd);
      _this.setState({ moving: true });
    };

    _this._handleTouchMove = function (e) {
      if (!_this.state.moving) {
        return;
      }

      _this._calcNewTime(e);
    };

    _this._handleTouchEnd = function (e) {
      _this._calcNewTime(e);
      if (_this._face && !_this._face.contains(e.target)) {
        captureNextEvent('click');
      }

      removeTouchEvent(window, 'move', _this._handleTouchMove);
      removeTouchEvent(window, 'end', _this._handleTouchEnd);

      _this.setState({ moving: false });
    };

    _this._calcNewTime = function (e) {
      var _ref = e.changedTouches ? e.changedTouches[0] : e,
          x = _ref.pageX,
          y = _ref.pageY;

      var innerRadius = _this.state.radius - 48;
      var _this$props2 = _this.props,
          onChange = _this$props2.onChange,
          minutes = _this$props2.minutes,
          timePeriod = _this$props2.timePeriod;

      onChange(calcTimeFromPoint({ x: x, y: y }, _this._center, innerRadius, minutes, timePeriod));
    };

    _this._enableMouseMoving = function () {
      window.addEventListener('mousemove', _this._handleMouseMove);
      window.addEventListener('mouseup', _this._handleMouseUp);

      _this.setState({ moving: true });
    };

    _this._disableMouseMoving = function () {
      window.removeEventListener('mousemove', _this._handleMouseMove);
      window.removeEventListener('mouseup', _this._handleMouseUp);

      _this.setState({ moving: false });
    };

    _this.state = { radius: 136, moving: false };
    _this._center = {};
    return _this;
  }

  ClockFace.prototype.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('mousemove', this._handleMouseMove);
    window.removeEventListener('mouseup', this._handleMouseMove);

    removeTouchEvent(window, 'move', this._handleTouchMove);
    removeTouchEvent(window, 'end', this._handleTouchEnd);
    clearInterval(this.interval);
  };

  ClockFace.prototype.render = function render() {
    var _props = this.props,
        time = _props.time,
        minutes = _props.minutes,
        timePeriod = _props.timePeriod,
        onChange = _props.onChange,
        hoverMode = _props.hoverMode;
    var radius = this.state.radius;

    var size = !minutes && !timePeriod ? 24 : 12;
    var times = Array.apply(null, new Array(size)).map(function (_, i) {
      var clockTime = i + 1;
      if (minutes) {
        clockTime = clockTime * 5 % 60;
      } else {
        clockTime %= 24;
      }

      return React.createElement(ClockTime, {
        key: 'time-' + i,
        index: i + 1,
        time: clockTime,
        active: clockTime === time,
        radius: radius,
        onKeyboardFocus: onChange
      });
    });

    return React.createElement(
      'div',
      {
        ref: this._setFace,
        className: 'md-clock-face md-block-centered md-pointer--hover',
        onMouseDown: this._handleMouseDown,
        onMouseEnter: hoverMode ? this._handleMouseEnter : undefined,
        onMouseLeave: hoverMode ? this._handleMouseLeave : undefined,
        onTouchStart: this._handleTouchStart
      },
      React.createElement(ResizeObserver, { watchHeight: true, onResize: this._setPositioning }),
      times,
      React.createElement(ClockHand, { time: time, coords: radius, minutes: minutes })
    );
  };

  return ClockFace;
}(PureComponent);

ClockFace.propTypes = {
  /**
   * The current time for the clock.
   */
  time: PropTypes.number.isRequired,

  /**
   * Boolean if the clock is on the minutes view.
   */
  minutes: PropTypes.bool.isRequired,

  /**
   * A function to call when a new time is selected. It gives the
   * new time value. If it is 12 o'clock, 0 will be given.
   */
  onChange: PropTypes.func.isRequired,

  /**
   * An optional time period string. This should be either AM or PM
   * if the locale uses them.
   */
  timePeriod: PropTypes.string,

  /**
   * If true the hover mode of the Time Picker is activated.
   * In hover mode no clicks are required to start selecting an hour
   * and the timemode switches automatically when a time was chosen.
   * When a minute is selected the chosen time is applied automatically.
   */
  hoverMode: PropTypes.bool,

  onTimeChosen: PropTypes.func.isRequired
};
export default ClockFace;