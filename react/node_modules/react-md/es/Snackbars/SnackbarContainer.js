var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { findDOMNode } from 'react-dom';
import CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';
import deprecated from 'react-prop-types/lib/deprecated';

import getField from '../utils/getField';
import TICK from '../constants/CSSTransitionGroupTick';
import isInvalidAnimate from './isInvalidAnimate';
import Portal from '../Helpers/Portal';
import Snackbar from './Snackbar';

var CHAINED_TOAST_DELAY = 50;

/**
 * The `Snackbar` component is used for displaying a concise and small message to the user about
 * an operation performed.
 *
 * > The main component for the `Snackbar` is actually named the `SnackbarContainer`, so you need
 * to make sure the import is `react-md/lib/Snackbars` or `react-md/lib/Snackbars/SnackbarContainer`.
 * The first import is preferable.
 */

var SnackbarContainer = function (_PureComponent) {
  _inherits(SnackbarContainer, _PureComponent);

  function SnackbarContainer(props) {
    _classCallCheck(this, SnackbarContainer);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _initialiseProps.call(_this);

    var visible = !!props.toasts.length;
    _this.state = {
      visible: visible,
      toast: null
    };
    return _this;
  }

  SnackbarContainer.prototype.componentDidMount = function componentDidMount() {
    var toasts = this.props.toasts;

    if (toasts.length) {
      this._initAndToast(toasts[0]);
    }
  };

  SnackbarContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _nextProps$toasts = nextProps.toasts,
        toast = _nextProps$toasts[0];
    var _props$toasts = this.props.toasts,
        prevToast = _props$toasts[0];

    if (toast === prevToast || toast === this.state.toast) {
      return;
    }

    if (!toast) {
      this._createLeaveTimer();
    } else if (!this.state.visible) {
      this._initAndToast(toast);
    } else {
      this._createSwapTimer(toast);
    }
  };

  SnackbarContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._initTimeout) {
      clearTimeout(this._initTimeout);
    }

    if (this._leaveTimeout) {
      clearTimeout(this._leaveTimeout);
    }

    if (this._swapTimeout) {
      clearTimeout(this._swapTimeout);
    }

    if (this._dismissTimeout) {
      clearTimeout(this._dismissTimeout);
    }
  };

  /**
   * This function takes in a new toast object and checks if the message will span
   * multiple lines of text by creating the new snackbar before the `Snackbar` component
   * gets made, checking the height of the message, and then removing the temporary
   * snackbar.
   */


  SnackbarContainer.prototype.render = function render() {
    var _state = this.state,
        visible = _state.visible,
        toast = _state.toast,
        multiline = _state.multiline;

    var _props = this.props,
        transitionName = _props.transitionName,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        dismiss = _props.dismiss,
        onDismiss = _props.onDismiss,
        lastChild = _props.lastChild,
        portal = _props.portal,
        propRenderNode = _props.renderNode,
        toasts = _props.toasts,
        props = _objectWithoutProperties(_props, ['transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'dismiss', 'onDismiss', 'lastChild', 'portal', 'renderNode', 'toasts']);

    var renderNode = getField(this.props, this.context, 'renderNode');

    var snackbar = void 0;
    if (toast) {
      snackbar = React.createElement(Snackbar, _extends({}, props, {
        key: 'snackbar',
        leaveTimeout: transitionLeaveTimeout,
        toast: toast,
        multiline: multiline,
        onDismiss: onDismiss || dismiss
      }));
    }

    var container = React.createElement(
      CSSTransitionGroup,
      {
        ref: this._setContainer,
        key: 'container',
        className: 'md-snackbar-container',
        transitionName: transitionName,
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout
      },
      snackbar
    );

    if (!portal) {
      return visible ? container : null;
    }

    return React.createElement(
      Portal,
      { visible: visible, renderNode: renderNode, lastChild: lastChild },
      container
    );
  };

  return SnackbarContainer;
}(PureComponent);

SnackbarContainer.propTypes = {
  /**
   * An id for the Snackbar once a toast has been added and is visible. This is a recommended
   * prop for accessibility concerns. If it is omitted, the id will become `'snackbar-alert'`
   * when there is no action on the toast, or `'snackbar-alert-dialog'` when there is an action
   * on the toast.
   */
  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * An optional style to apply to the snackbar once it appears.
   */
  style: PropTypes.object,

  /**
   * An optional className to apply to the snackbar once it appears.
   */
  className: PropTypes.string,

  /**
   * An immutable controlled queue of toasts that should appear in the snackbar.
   * The snackbar will always display the first toast in this list. When the user has
   * either clicked the action of the toast, or the `autohideTimeout` has been reached,
   * the `onDismiss` function will be called. The `onDismiss` function should remove the
   * first toast and return a new list of remaining toasts.
   *
   * ```js
   * let toasts = [];
   * const onDismiss = () => {
   *   const [, ...remainingToasts] = toasts;
   *   toasts = remainingToasts;
   * };
   * ```
   */
  toasts: PropTypes.arrayOf(PropTypes.shape({
    /**
     * The text to display in the toast.
     */
    text: PropTypes.node.isRequired,

    /**
     * An optional action to take. If this value is a string, the `label` for the
     * button will be this value, Otherwise, all the keys in the action object will
     * be applied to the `Button`.
     */
    action: PropTypes.oneOfType([PropTypes.node, PropTypes.shape({
      onClick: PropTypes.func,
      children: PropTypes.node,
      // Deprecated
      label: PropTypes.node
    })])
  })).isRequired,

  /**
   * A function to call that will dismiss a toast. This will automatically be bound to
   * any toast that has an `action` and it will also be called when the `autohideTimeout`
   * has been reached.
   */
  onDismiss: PropTypes.func.isRequired,

  /**
   * Boolean if the snackbar's toasts should automatically be dismissed after the
   * `autohideTimeout` has been reached.
   */
  autohide: PropTypes.bool,

  /**
   * The amount of time before the snackbar should be dequeued and the next toast
   * should be displayed.
   */
  autohideTimeout: PropTypes.number.isRequired,

  /**
   * When a toast has an action, it will automatically be focused when this prop is enabled.
   * This will require your action onClick handler to correctly focus an element on the page
   * once the toast is hidden. If this prop is disabled, it is recommended to add custom focus
   * logic so that keyboard users can interact with the snackbar.
   */
  autoFocusAction: PropTypes.bool,

  /**
   * The transition name to use for the snackbar appearing and disappearing.
   */
  transitionName: PropTypes.string.isRequired,

  /**
   * The transition time for the snackbar to enter. This should match the `$md-snackbar-transition-time`
   * sass variable.
   */
  transitionEnterTimeout: PropTypes.number.isRequired,

  /**
   * The transition time for the snackbar to leave. This should match the `$md-snackbar-transition-time`
   * sass variable.
   */
  transitionLeaveTimeout: PropTypes.number.isRequired,

  /**
   * When the app contains a floating action button that is fixed to the bottom of the screen,
   * you should set this to be a ref of the floating action button. When a snackbar appears,
   * the FAB will be moved to not overlay the snackbar.
   */
  fab: function fab(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);

    if (!propValue) {
      return null;
    }

    if (propType !== 'object' || typeof propValue.render !== 'function' || isInvalidAnimate(propValue)) {
      var componentNameSafe = componentName || '<<anonymous>>';
      var propFullNameSafe = propFullName || propName;
      return new Error('Invalid ' + location + ' `' + propFullNameSafe + '` supplied to `' + componentNameSafe + '`, expected a ' + 'ref to a floating `Button` component. This should not be a DOMElement from `findDOMNode` but instead ' + 'the React ref object.');
    }

    return null;
  },

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the snackbar.
   *
   * @see {@link Helpers/Portal}
   */
  portal: PropTypes.bool,

  /**
   * An optional DOM node to render the Snackbar in. If this is omitted, it will render as the first
   * child in the `body`.
   */
  renderNode: PropTypes.object,

  /**
   * Boolean if the snackbar should render as the last child in the `renderNode` or `body` instead of
   * as the first.
   */
  lastChild: PropTypes.bool,
  dismiss: deprecated(PropTypes.func, 'Use `onDismiss` instead')
};
SnackbarContainer.defaultProps = {
  autoFocusAction: false,
  autohide: true,
  toasts: [],
  autohideTimeout: 3000,
  transitionName: 'md-snackbar',
  transitionEnterTimeout: 300,
  transitionLeaveTimeout: 300
};
SnackbarContainer.contextTypes = {
  renderNode: PropTypes.object
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setContainer = function (container) {
    _this2._container = findDOMNode(container);
  };

  this._isMultiline = function (toast) {
    var container = _this2._container;
    if (container === null) {
      return false;
    }

    var message = document.createElement('p');
    message.classList.add('md-snackbar--toast');
    message.innerHTML = toast.text;

    var snackbar = void 0;
    if (toast.action) {
      message.classList.add('md-snackbar--action');

      snackbar = document.createElement('section');
      snackbar.className = 'md-snackbar';
      snackbar.appendChild(message);

      var action = document.createElement('button');
      action.innerHTML = typeof toast.action === 'string' ? toast.action : toast.action.label;
      action.className = 'md-btn md-btn--flat md-btn--text md-btn--snackbar';
      snackbar.appendChild(action);
    } else {
      snackbar = message;
    }

    // Only style we really want from the .md-snackbar
    snackbar.style.maxWidth = '568px';

    container.appendChild(snackbar);
    var multiline = message.offsetHeight > 20;
    container.removeChild(snackbar);

    return multiline;
  };

  this._initAndToast = function (toast) {
    _this2._initTimeout = setTimeout(function () {
      _this2._initTimeout = null;

      _this2.setState({ toast: toast, multiline: _this2._isMultiline(toast) });
    }, TICK);

    _this2.setState({ visible: true });
  };

  this._createLeaveTimer = function () {
    var time = _this2.props.transitionLeaveTimeout;

    _this2._leaveTimeout = setTimeout(function () {
      _this2._leaveTimeout = null;

      _this2.setState({ visible: false });
    }, time + TICK);

    _this2.setState({ toast: null });
  };

  this._createSwapTimer = function (toast) {
    _this2._swapTimeout = setTimeout(function () {
      _this2._swapTimeout = null;

      _this2.setState({ toast: toast, multiline: _this2._isMultiline(toast) });
    }, _this2.props.transitionLeaveTimeout + CHAINED_TOAST_DELAY);

    _this2.setState({ toast: null });
  };
};

export default SnackbarContainer;