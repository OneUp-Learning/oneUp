'''
Created on Sep 10, 2016
Last Updated Sep 12, 2016

'''
from django.template import RequestContext
from django.shortcuts import render
from Instructors.models import Announcements, Courses, Challenges
from Instructors.models import Skills, Courses, CoursesSkills 
from Badges.models import CourseConfigParams
from Badges.models import Badges, Courses
from Students.models import StudentConfigParams, StudentBadges,StudentChallenges,Student,StudentCourseSkills
from Instructors.views.announcementListView import createContextForAnnouncementList
from Instructors.views.upcommingChallengesListView import createContextForUpcommingChallengesList
from _datetime import datetime, tzinfo
from time import time, strptime, struct_time
from time import strftime
from datetime import datetime, timedelta



def instructorCourseHome(request):
 
    context_dict = { }
    context_dict["logged_in"]=request.user.is_authenticated()
    if request.user.is_authenticated():
        context_dict["username"]=request.user.username

    if request.GET:
        request.session['currentCourseID'] = request.GET['courseID']
        
    if 'currentCourseID' in request.session:
        currentCourse = Courses.objects.get(pk=int(request.session['currentCourseID']))
        context_dict = createContextForAnnouncementList(currentCourse, context_dict, True)
        context_dict = createContextForUpcommingChallengesList(currentCourse, context_dict)
        context_dict['course_Name'] = currentCourse.courseName
        
        ccparamsList = CourseConfigParams.objects.filter(courseID=currentCourse)
            
        if len(ccparamsList) > 0:
            ccparams = ccparamsList[0] 
            context_dict["badgesUsed"]=ccparams.badgesUsed
            context_dict["leaderboardUsed"]=ccparams.leaderboardUsed
            context_dict["classSkillsDisplayed"]=ccparams.classSkillsDisplayed
            context_dict["classRankingDisplayed "]=ccparams.classRankingDisplayed
            
        #Leaderboard Badges
#         StudentBadges(models.Model):
#     studentBadgeID = models.AutoField(primary_key=True)
#     studentID = models.ForeignKey(Student, verbose_name="the student", db_index=True)
#     badgeID = models.ForeignKey(Badges, verbose_name="the badge", db_index=True)
#     objectID = models.IntegerField(default=-1,verbose_name="index into the appropriate table") #ID of challenge,assignment,etc. associated with a badge
#     timestamp = models.DateTimeField() ## Timestamp for badge assignment date
        badgeId = [] 
        studentBadgeID=[]
        studentID=[]
        badgeID=[]
        badgeName=[]
        badgeImage = []
        avatarImage =[]
        timestamp=[]
        N = 7

        date_N_days_ago = datetime.now() - timedelta(days=N)

        print ( datetime.now())
        print ("date_N_days_Ago")
        print (date_N_days_ago)
        
        
        #Displaying the list of challenges from database
        badges = StudentBadges.objects.all().order_by('-timestamp')
       
        for badge in badges:
            studentBadgeID.append(badge.studentBadgeID)
            studentID.append(badge.studentID)
            badgeID.append(badge.badgeID)
            badgeName.append(badge.badgeID.badgeName)
            badgeImage.append(badge.badgeID.badgeImage)
            avatarImage.append(badge.studentID.avatarImage)
#                 timestamp.append(badge.timestamp)
                          
            # The range part is the index numbers.
        context_dict['badgesInfo'] = zip(range(1,badges.count()),studentBadgeID,studentID,badgeID,badgeImage,avatarImage)
        print (badgeID)
        print(studentID)
        print (badgeName)
#         print (badge.timestamp)  
            ## Leaderboard Points
            
        ## Get the studentID for the course, then for each student in a loop get the total for all challenges for a student in that course
#         studentGradedChallenges = []
#         studentChallenges = StudentChallenges.objects.filter(studentID=studentID, courseID=currentCourse)
#         for st_challenge in studentChallenges:
#             if st_challenge.challengeID.isGraded:
#                 studentGradedChallenges.append(st_challenge)
#             for lp in studentGradedChallenges:
#                      
#                     studentChall_ID.append(lp.studentChallengeID) #pk
#                     chall_ID.append(lp.challengeID.challengeID) 
#                     total.append(lp.testTotal) 
#                     avatarImage.append(lp.studentID.avatarImage)           
#                 
#         context_dict['leaderpoints_range'] = zip(range(1,len(studentGradedChallenges)+1),studentChall_ID,chall_ID,total,avatarImage)
        # The range part is the index numbers.
         #Leaderboard Skills       
          #Displaying the list of students from database
        user = Student.objects.all()
        
        avatarImage =[]
        print (user)
        num_users = user.count()
        skill_ID = []      
        skill_Name = []
        skill_Name = []         
        skill_Points = []
        skillTotal_Points = []
        
        
        for i in range(3, num_users):
            # Extract Skills data for the current student
            # First get all skills for this course
                     
                print("[LBSkills]:{{lineno:124}:Skills StudentID", studentID[1])
                cskills = CoursesSkills.objects.filter(courseID=currentCourse)
#                 print(CoursesSkills.objects.all())
                num_cskills = cskills.count()
                print("[LBSkills]:{lineno:128}:User Loop Count", i,"skills Count",num_cskills)
#                 print("[LBSkills]:",cskills)
                for j in range (7, num_cskills):
                    for csk in cskills:
                        skill_ID.append(csk.skillID.skillID) 
                        skills = Skills.objects.filter(skillID=csk.skillID.skillID)
#                         print("Skills.objects.filter",skills)
                        print("[LBSkills]{lineno:135}:Skills.objects.filter",csk.skillID.skillName)
                        
#                         for sk in skills:
#                             skill_Name.append(sk.skillName)
#                             skill_ID.append(sk.skillID)
#                             print("Skill ID", skill_ID, "Skill Name", skill_Name)
#                             
                            #Displaying the list of skills from database   
                        studentSkills = StudentCourseSkills.objects.filter(studentChallengeQuestionID__studentChallengeID__studentID=user[0], skillID=csk.skillID.skillID, studentChallengeQuestionID__studentChallengeID__courseID=currentCourse)
                        if not studentSkills:
                                print('No skills')
                                context_dict['no_skill'] = 'Sorry!! there are no skills associated with the course chosen..'
                        else:     
                                for studentSkill in studentSkills:
                                    count = 0;
                                    defskillTotalCount = 0;
                                    skill_ID.append(studentSkill.skillID) #pk
                                    skill_Name.append(studentSkill.skillID.skillName)
                                    skill_Points.append(studentSkill.skillPoints)
                                    defskillTotalCount = defskillTotalCount + studentSkill.skillPoints
                                    skillTotal_Points.append(defskillTotalCount)
#                                     print("[LBSkills]:skillTotal_Points",skillTotal_Points)
#                                     print("[LBSkills]:student_ID",i,"Skill_Count:", j,"skill_Name",csk.skillID.skillName,"skill_Points",skill_Points,"defskillTotalCount:",str(defskillTotalCount))
                                    print("[LBSkills]{lineno:158}:student_ID",i
                                          ,"Skill_Count:", j
                                          ,"skill_Name",csk.skillID.skillName
#                                           ,"skill_Points",skill_Points
                                          ,"defskillTotalCount:",str(skillTotal_Points)
                                          )
        
#         # The range part is the index numbers.
#         context_dict['skillTotal_range'] = zip(range(1,studentSkills.count()+1),skill_ID,skill_Name,skill_Points,skillTotal_Points)   
    
    # Leaderboard based on XP Points
    #Displaying the list of challenges from database
        challenges = Challenges.objects.filter(courseID=currentCourse, isGraded=True,  isVisible=True)
        num_challs = challenges.count()
        allgrades = []
        gradeTotal = []
        first_Name= []
        last_Name= []
        chall_Name= []
        

        #Displaying the list of students from database
        user = Student.objects.all()
        avatarImage =[]
        print ("[LBXP-Points]:",user)
        num_users = user.count()
        
        for i in range(0, num_users):  
            grade = []
            gradeMax = []
            number  = []
            numberMax  = []
            sc_user = []
            sc_chall = []
            
            for j in range(0, num_challs):  
                if StudentChallenges.objects.filter(studentID=user[i], courseID=currentCourse, challengeID = challenges[j]) :
                    
                    sChallenges = StudentChallenges.objects.filter(studentID=user[i], courseID=currentCourse, challengeID = challenges[j])
                    gradeID  = []
                    
                    for sc in sChallenges:
                        gradeID.append(int(sc.testScore))
                    numberMax.append(max(gradeID))
                    
                else:
                    numberMax.append(0)
                number = numberMax
            gradeTotal.append(("%0.2f" %sum(number)))
                
        for u in user:
            avatarImage.append(u.avatarImage)
        gradeTotal.sort(reverse=True)
        context_dict['user_range'] = zip(range(1,user.count()+1),avatarImage, gradeTotal)
            
    else:
        context_dict['course_Name'] = 'Not Selected'
        
    return render(request,'Instructors/InstructorCourseHome.html', context_dict)
