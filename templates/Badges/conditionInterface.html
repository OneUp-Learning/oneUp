     <style>
      .cond-prototype {
        display: none;
      }
      .cond-item {
        border-style: solid;
        border-width: 1px;
        border-radius: 6px;
        border-color: dimgray;
        text-align: center;
        padding: 2px;
        min-width: auto;
        min-height: auto;
        flex: none;
      }
      .cond-empty {
        border-style: dashed;
        border-width: 1px;
        border-radius: 6px;
        border-color: dimgray;
        text-align: center;
        min-width: 4em;
        min-height: 1em;
      }
      .cond-container {
        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        justify-content: flex-start;
        align-items: stretch;
        align-content: flex-start;
        height: 400px;
        min-height: 0px;
        width: 100%;
        overflow-x: auto;
        overflow-y: scroll;
      }
      .cond-icon-list {
        display: flex;
        flex-direction: row:
        align-items: stretch;
      }
      .cond-icon {
        border-style: solid;
        border-width: 1px;
        border-radius: 6px;
        padding: 6px;
      }
      .cond-trash {
        margin-left: auto;
      }
      .cond-or {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        align-items: center;
        overflow-x: auto;
        overflow-y: hidden;
        background-color: #DDFFFF;
      }
      .cond-or-sub {
        flex-basis: 45%;
        height: 100%;
      }
      .cond-or-label {
        color: silver;
        flex-basis: 8%;
        text-align: center;
      }
      .cond-and-label {
        font-size: 0.6em;
        color: silver;
        text-align: center;
      }
      .cond-atom-option-group {
      }
      .cond-for {
        background-color: yellow;
        align-items: center;
        display: flex;
        flex-direction: column;
      }
      .cond-for-list {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
      }
      .cond-for-list-item {
        padding: 2px;
        background-color: orange;
      }
      .cond-for-sub {
        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        width: 90%;
      }
      .cond-atom {
        background-color: #EEFFEE;
        overflow: hidden;
      }
    </style>
 <!-- Hidden prototypes which will be copied to make the actual nodes in the boolean expression. -->
    <div id="condOrPrototype" class="cond-prototype">
      <div class="cond-or cond-item" data-cond-type="or" draggable="true">
		<div class="cond-or-sub" data-cond-type="orSub">
	  	  <div class="cond-empty" data-cond-type="orBlank">&nbsp;</div>
	    </div>
		<div class="cond-or-label">OR</div>
		<div class="cond-or-sub" data-cond-type="orSub">
	  	  <div class="cond-empty" data-cond-type="orBlank">&nbsp;</div>
		</div>
      </div>
    </div>
    <div id="condEmptyOrSubPrototype" class="cond-prototype">
      <div class="cond-or-sub" data-cond-type="orSub">
		<div class="cond-empty" data-cond-type="orBlank">&nbsp;</div>
      </div>
    </div>
    <div id="condOrLabelPrototype" class="cond-prototype">
      <div class="cond-or-label">OR</div>
    </div>
    <div id="condAtomPrototype" class="cond-prototype">
      <div class="cond-item cond-atom" data-cond-type="atom" draggable="true">
		<select name="cond-var" onchange="condChangeAtomToMatchType(this);return true;">
	  	  <option value="0" data-cond-var-type="text" data-cond-context-global="true" data-cond-context-challenge="true" data-cond-context-activity="true">choose a variable</option>
		  {% for variable in variables %}
		  	<option value="{{variable.id}}" data-cond-var-type="{{variable.type}}" title="{{variable.tooltip}}"
		  	  {% for object in variable.objects %}
		  	    data-cond-context-{{object}}="true";
		  	  {% endfor %}
		  	> {{variable.name}} </option>
		  {% endfor %}
		</select>
		<select name="cond-op">
	  	  <option value="=">=</option>
	  	  <option value=">">&gt;</option>
	  	  <option value="<">&lt;</option>
		</select>
		<input type="text" name="cond-rhs-value" class="cond-rhs-value">
		<select name="cond-rhs-var" hidden>
	  	  <option value="0" data-cond-context-global="true" data-cond-context-challenge="true" data-cond-context-activity="true">choose a variable</option>
		  {% for variable in variables %}
		  	<option value="{{variable.id}}" data-cond-var-type="{{variable.type}}" title="{{variable.tooltip}}"
		  	  {% for object in variable.objects %}
		  	    data-cond-context-{{object}}="true";
		  	  {% endfor %}
		  	> {{variable.name}} </option>
		  {% endfor %}
		</select>
		<label><input type="checkbox" name="cond-value" checked="true" onchange="condToggleAtomType(this)">value</input></label>
      </div>
    </div>
    <div id="condAndLabelPrototype" class="cond-prototype">
      <div class="cond-and-label">AND</div>
    </div>
    <div id="condEmptyAndPrototype" class="cond-prototype">
      <div class="cond-empty" data-cond-type="andBlank">&nbsp;</div>
    </div>
    <div id="condForPrototype" class="cond-prototype">
      <div class="cond-for cond-item" data-cond-type="for" 
		   data-inside-qualifier="{{defaultObject}}" draggable="true">
		<div>
		  	for
		  	<select name="allOrAny">
		   	 	<option value="all">each</option>
		    	<option value="any">any</option>
		  	</select>
		  	of the following
		  	<select name="type" onchange="condChangeForAllType(this);return true;"
				  data-cond-old-type="{{defaultObject}}">
				{% for objectType in objectTypes %}
		    		<option value="{{objectType.name}}">{{objectType.plural}}</option>
		    	{% endfor %}
		  	</select>
		</div>
		{% for objectType in objectTypes %}
			<div class="cond-{{objectType.name}}-list" {% if objectType.name != defaultObject %} hidden {%endif%}>
			  <select name="{{objectType.name}}-list" 
				  onchange="condAddThingieToList(this);this.selectedIndex=0;">
		    	<option value="0">select {{objectType.plural}} to add</option>
		    	{% for object in objectType.objects %}
			    	<option value="{{object.id}}">{{object.name}}</option>
			    {% endfor %}
		  	  </select>
		  	  or <input type="checkbox" name="{{objectType.name}}-all">
			  <label for="{{objectType.name}}-all">all {{objectType.plural}}</label>
			</div>
			<div class="cond-for-list cond-{{objectType.name}}-selected-list">
			</div>  
		{% endfor %}
		<div class="cond-for-sub">
			<div class="cond-empty">&nbsp;</div>
		</div>
      </div>
    </div>

<!-- Icons -->
    <p>
    <div class="cond-icon-list">
      <div id="condOrIcon" class="cond-icon" draggable="true">OR</div>
      <div id="condAtomIcon" class="cond-icon" draggable="true">Atom</div>
      <div id="condForAllIcon" class="cond-icon" draggable="true">Forall</div>
      <div id="condTrashIcon" class="cond-icon cond-trash"> Trash </div>
    </div>
    </p>

<!-- Container for initial condition -->
    <div class="cond-container cond-item">
      <input type="hidden" value="0" name="cond-cond-string" id="cond-cond-string">
      <input type="hidden" value="0" class="cond-atom-count" name="cond-atom-count" id="cond-atom-count">
      <div class="cond-empty" data-cond-inside-qualifier="none">&nbsp;</div>
    </div>

    <script>
      function condFilterChildren(node,proposition) {
    	  var output = [];
    	  for (var i=0;i<node.children.length;i++) {
    		  if (proposition(node.children[i])) {
    			  output.push(node.children[i]);
    		  }
    	  }
    	  return output;
      }
    
      function condToggleAtomType(x) {
    	  var atom = x.parentNode.parentNode;
    	  var value = atom.getElementsByClassName('cond-rhs-value')[0];
          var variable = atom.querySelector('select[name="cond-rhs-var"]');
    	  if (x.checked) {
    		  variable.hidden = true;
    		  value.removeAttribute("hidden");
    	  } else {
    		  value.hidden = true;
    		  variable.removeAttribute("hidden");
    	  }
      }
    
      function condChangeAtomToMatchType(select) {
    	  console.log("changing atom type");
    	  var atom = select.parentNode.parentNode;
    	  var option = select.options[select.selectedIndex];
    	  var type = option.dataset.condVarType;
    	  var value = atom.getElementsByClassName('cond-rhs-value')[0];
    	  var valueParent = value.parentNode;
    	  if (type != value.type) {	  
	    	  // We have to remake the value node in order to change the type in some web browsers, so we just do it for everyone.
	    	  var newValue = document.createElement('input');
	    	  newValue.type = type;
	    	  newValue.name = value.name;
			  newValue.classList.add("cond-rhs-value");
	    	  
	    	  // We save the type-specific value so that changing types doesn't destroy values.
	    	  atom.dataset["condSavedValue_"+value.type] = value.value;
	    	  // And then we restore an old one if it exists
	    	  if (atom.dataset["condSavedValue_"+type]) {
	    		  newValue.value = atom.dataset["condSavedValue_"+type];
	    	  }
	    	  
	    	  valueParent.insertBefore(newValue,value);
	    	  valueParent.removeChild(value);
	    	  value = newValue;
    	  }
	    	 
    	  function disable(opt) {
    		  opt.hidden = "true";
    	  }
    	  function enable(opt) {
    		  opt.removeAttribute("hidden");
    	  }
    	  var justEqual = { "=":enable, ">":disable, "<":disable };
    	  var allOps = { "=":enable, ">":enable, "<":enable };
    	  var typeStatusChange = { text: justEqual, date: allOps, number: allOps, checkbox: justEqual };
    	  
    	  var operator = atom.querySelector('select[name="cond-op"]');
    	  for (var i = 0; i<operator.options.length; i++) {
    		  typeStatusChange[type][operator.options[i].value](operator.options[i]);
    	  }
      }
      
      // All names prefixed with cond to decrease odds of any sort
      // of name-space conflict on import.

      /******************************************
       * Functions for handling ForAll UI stuff *
       ******************************************/
      
      function condAddThingieToListByNameAndId(list,name,id) {
        var itemDiv = document.createElement("div");
        itemDiv.onclick = function(e){condRemoveThingie(this)};
        itemDiv.dataset.id = id;
        itemDiv.className = "cond-for-list-item";
        var name_text = document.createTextNode(name+" \u00D7");
        itemDiv.appendChild(name_text);
        list.appendChild(itemDiv);
      }

      function condAddThingieToList(select) {
        var choice = select.options[select.selectedIndex];
        var list = select.parentNode.nextElementSibling;
        var listOfIds = [];
        for (var i = 0; i<list.children.length; i++) { //>
          listOfIds.push(list.children[i].dataset.id);
        }
        if (!listOfIds.includes(choice.value)) {
          condAddThingieToListByNameAndId(list,choice.text,choice.value);
        }
      }

      function condRemoveThingie(item) {
        item.parentNode.removeChild(item);
      }

      var condForAllTypeList = ["challenge","activity",]
      function condChangeForAllType(select) {
        var currentType = select.options[select.selectedIndex].value;
        var oldType = select.dataset.condOldType;
        if (currentType == oldType) {
          return;
        }
        select.dataset.condOldType = currentType;
        var forAllDiv = select.parentNode.parentNode
        var listDivs = {};
        var selectedDivs = {};
        for (var i=0; i<condForAllTypeList.length; i++) {
        	var typeI = condForAllTypeList[i];
        	listDivs[typeI] = forAllDiv.getElementsByClassName("cond-"+typeI+"-list")[0];
       		selectedDivs[typeI] = forAllDiv.getElementsByClassName("cond-"+typeI+"-selected-list")[0];
        }
        listDivs[oldType].hidden = "true";
        selectedDivs[oldType].hidden = "true";
        selectedDivs[oldType].style.display = "none";
        listDivs[currentType].removeAttribute("hidden");
        selectedDivs[currentType].removeAttribute("hidden");
        selectedDivs[currentType].style.display = "flex";

        var subDivs = forAllDiv.getElementsByTagName("DIV");
        [].forEach.call(subDivs,function(subDiv) {
          subDiv.dataset.condInsideQualifier = currentType;
        });
        
        condUpdateAtomSelectForContext(forAllDiv,currentType);
        
        return true;
      }

      /*********************************************
       * Functions relating to draggable interface *
       *********************************************/

      var condDragSource = null;
      var condSourceType = null;

      // The two condHandleDragStart functions are used to set up
      // visual effects and note the drag source when a drag event begins.

      // This one is used for the icons at the top which will be copied
      // into the condition container.
      function condHandleDragStartCopy(e) {
        this.style.opacity = 0.4;
        condDragSource = this;
        condSourceType = "copy";
        e.dataTransfer.setData('text','icon drag');
        e.dataTransfer.effectAllowed = "copy";

        e.stopPropagation();
      }

      // This one is used for the parts of the condition itself which
      // can be dragged around in order to redo things.
      function condHandleDragStartMove(e) {
        this.style.opacity = 0.4;
        if (!this.id) {
          this.id = "cond-id-"+(Date.now()+Math.random()).toString(36);
        }
        condDragSource = this;
        condSourceType = "move";
        e.dataTransfer.setData('text','move drag');
        e.dataTransfer.effectAllowed = "move";

        e.stopPropagation();
      }
      function condHandleDragEnd(e) {
        this.style.opacity = 1.0;
      }

      function condCanDropOn(source,target) {
        var canDrop = true;
        if ((target.dataset.condType=="orBlank") && 
            (source.id=="condOrIcon")) {
          canDrop = false;
        }

        if ((target.dataset.condInsideQualifier!="none") &&
            (source.id=="condForAllIcon")) {
          canDrop = false;
        }

        if (target.parentNode == source.parentNode) {
          canDrop = false;
        }

        if ((target.dataset.condInsideQualifier!="none") &&
            (source.dataset.condType=="for")) {
          canDrop = false;
        }

        var targetAncestor = target;
        while (targetAncestor.parentNode) {
          if (source == targetAncestor) {
            canDrop = false;
          }
          targetAncestor = targetAncestor.parentNode;
        }
          
        return canDrop;

      }

      function condHandleDragOverBlank(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }

        if (!condCanDropOn(condDragSource,this)) {
          e.dataTransfer.dropEffect = "none";
          return false;
        }

        e.dataTransfer.dropEffect = condSourceType;
        return false;
      }

      function clonePrototype(name) {
        var prototypeSuperDiv = document.getElementById(name);
        var prototypeDiv = prototypeSuperDiv.getElementsByTagName('div')[0].cloneNode(true);
        return prototypeDiv;
      }

      function condUpdateAtomSelectForContext(targetDiv,context) {

    	  if (context == "none") {
    		  context = "global";
    	  }
    	  context = context.charAt(0).toUpperCase() + context.slice(1);
    	  var contextAttributeName = "condContext"+context;
    	  
    	  function updateThisSelect(targetSelect,contextAttributeName, rhs) {
        	  var inputs = targetSelect.getElementsByTagName("option");
        	  for (var i = 0; i < inputs.length; i++) {
        		  if (inputs[i].dataset[contextAttributeName] || (rhs && inputs[i].dataset["condContextGlobal"])) {
        			  inputs[i].removeAttribute("hidden");
        		  } else {
        			  inputs[i].hidden = true;
        		  }
        	  }
    	  }
    	  
    	  var selects = targetDiv.getElementsByTagName("select");
          for (var i = 0; i < selects.length; i++) {
        	var curSelect = selects[i];
          	if (curSelect.name == "cond-var") {
          		updateThisSelect(curSelect,contextAttributeName, false);
              	if (!curSelect.options[curSelect.selectedIndex].dataset[contextAttributeName]) {
              		curSelect.selectedIndex = 0;
              	}          		
          	} else if (curSelect.name == "cond-rhs-var") {
          		updateThisSelect(curSelect,contextAttributeName, true);
              	if (!curSelect.options[curSelect.selectedIndex].dataset[contextAttributeName]) {
              		curSelect.selectedIndex = 0;
              	}
          	}
          }
      }
      
      var atomCountInput = document.querySelector('input.cond-atom-count');
      function condCountNewAtom() {
    	  var count = parseInt(atomCountInput.value);
    	  atomCountInput.value=count+1;
    	  return count;
      }
      
      function condCreateAtomNode(targetParent,blank,insideQualifier) {
        var atomDiv = clonePrototype("condAtomPrototype");
        targetParent.insertBefore(atomDiv,blank);
        var labelDiv = clonePrototype("condAndLabelPrototype");
        targetParent.insertBefore(labelDiv,blank);
        var blankDiv = clonePrototype("condEmptyAndPrototype");
        targetParent.insertBefore(blankDiv,blank);
        condPrepareEmptyDescendants(blankDiv,insideQualifier);

        atomDiv.addEventListener("dragstart",condHandleDragStartMove,false);
        atomDiv.addEventListener("dragend",condHandleDragEnd,false);

	var value = atomDiv.getElementsByClassName('cond-rhs-value')[0];
	value.name = "cond-rhs-value"+condCountNewAtom();
        
        condUpdateAtomSelectForContext(atomDiv,insideQualifier);
        
        return atomDiv;
      }
      function condCreateOrNode(targetParent,blank,insideQualifier) {
        var orDiv = clonePrototype("condOrPrototype");
        targetParent.insertBefore(orDiv,blank);
        var labelDiv = clonePrototype("condAndLabelPrototype");
        targetParent.insertBefore(labelDiv,blank);
        var blankDiv = clonePrototype("condEmptyAndPrototype");
        targetParent.insertBefore(blankDiv,blank);
        condPrepareEmptyDescendants(orDiv,insideQualifier);
        condPrepareEmptyDescendants(blankDiv,insideQualifier);

        orDiv.addEventListener("dragstart",condHandleDragStartMove,false);
        orDiv.addEventListener("dragend",condHandleDragEnd,false);

        return orDiv;
      }
      function condExpandOrNode(targetParent,insideQualifier) {
        var labelDiv = clonePrototype("condOrLabelPrototype");
        targetParent.appendChild(labelDiv);
        var blankSubDiv = clonePrototype("condEmptyOrSubPrototype");
        targetParent.appendChild(blankSubDiv);
        condPrepareEmptyDescendants(blankSubDiv,insideQualifier);
        return blankSubDiv;
      }
      function condCreateForAllNode(targetParent,blank) {
        var blankDiv = clonePrototype("condEmptyAndPrototype");
        targetParent.insertBefore(blankDiv,blank);
        var labelDiv = clonePrototype("condAndLabelPrototype");
        targetParent.insertBefore(labelDiv,blank);
        var forAllDiv = clonePrototype("condForPrototype");
        targetParent.insertBefore(forAllDiv,blank);
        condPrepareEmptyDescendants(blankDiv,"none");
        condPrepareEmptyDescendants(forAllDiv,"challenge");

        forAllDiv.addEventListener("dragstart",condHandleDragStartMove,false);
        forAllDiv.addEventListener("dragend",condHandleDragEnd,false);

        return forAllDiv;
      }

      function condOrIsFull(orNode) {
        return (condCountEmptyOrSubs(orNode) == 0);
      }
      
      function condOrSubIsEmpty(orSubNode) {
    	  return orSubNode.getElementsByClassName("cond-item").length == 0;
      }
      
      function condCountEmptyOrSubs(orNode) {
          var numEmptySubs = 0;
          var orSubs = orNode.getElementsByClassName("cond-or-sub");
          for (var i = 0; i < orSubs.length; i++) {
          	if (condOrSubIsEmpty(orSubs[i])) {
  	    		numEmptySubs++;
  	  		}
          }
          return numEmptySubs;
      }

      function condCleanUpOr(orNode) {
        var orSubs = orNode.getElementsByClassName("cond-or-sub");
        if (orSubs.length == 2) {
          return;
        }
        var emptyCount = 0;
        var subItems = [];
        for (var i = 0; i < orSubs.length; i++) {
          subItems[i] = orSubs[i].getElementsByClassName("cond-item");
          if (subItems[i].length == 0) {
            emptyCount += 1;
          }
        }

        var j = 0;
        while (emptyCount > 1) {
	  if (subItems[j].length == 0) {
            orNode.removeChild(orSubs[j].nextElementSibling);
            orNode.removeChild(orSubs[j]);
	    emptyCount -= 1;
	  }
	  j++;
	}   
      }

      // This function adds event listeners and also sets the flag
      // for whether or not they are inside a qualifier block
      function condPrepareEmptyDescendants(node,insideQualifier) {
        function prepareEmptyDescendantsHelper(node) {
          if (node.nodeName == "DIV") {
            node.dataset.condInsideQualifier = insideQualifier;
            if (node.classList.contains("cond-empty")) {
              node.addEventListener("dragover",condHandleDragOverBlank,false);
              node.addEventListener("drop",condHandleDropOnBlank,false);
            }
          }
          // Recursive call for all children
          [].forEach.call(node.childNodes,prepareEmptyDescendantsHelper);
        }
        prepareEmptyDescendantsHelper(node);
      }

	function condHandleDropOnBlank(e) {
		if (e.preventDefault) {
        	e.preventDefault();
        }

        var targetParent = e.target.parentNode;
        var insideQualifier = e.target.dataset.condInsideQualifier;
        if (condDragSource.id == "condOrIcon") {
			condCreateOrNode(targetParent,e.target,insideQualifier);
			targetParent.removeChild(e.target);
        } else if (condDragSource.id == "condAtomIcon") {
			condCreateAtomNode(targetParent,e.target,insideQualifier);
			targetParent.removeChild(e.target);
        } else if (condDragSource.id == "condForAllIcon") {
			condCreateForAllNode(targetParent,e.target);
        	targetParent.removeChild(e.target);
        } else /* a node to be moved */ {
	 	 	var sourceParentIsOr = 
		    	condDragSource.parentNode.parentNode.dataset.condType == "or";
		  	var sourceOr;
		  	if (sourceParentIsOr) {
		    	sourceOr = condDragSource.parentNode.parentNode;
		  	}
	      	if ((condDragSource.dataset.condType == "or") || 
	        	(condDragSource.dataset.condType == "atom")) {
	        	var andLabelDiv = condDragSource.nextElementSibling;
	        	targetParent.insertBefore(condDragSource,e.target);
	        	targetParent.insertBefore(andLabelDiv,e.target);
	      	} else { // for
	        	var sourceAndLabelDiv = condDragSource.previousElementSibling;
	        	if (e.target.nextElementSibling) {
	          		var targetAndLabelDiv = e.target.nextElementSibling;
	          		targetParent.insertBefore(sourceAndLabelDiv,targetAndLabelDiv);
	          		targetParent.insertBefore(condDragSource,targetAndLabelDiv);
	       		} else { // Last on list.
	          		targetParent.appendChild(sourceAndLabelDiv);
	          		targetParent.appendChild(condDragSource);
	        	}
	      	}
		  	if (sourceParentIsOr) {
		    	condCleanUpOr(sourceOr);
		  	}
		  	condUpdateAtomSelectForContext(condDragSource,insideQualifier);
        }

        if (targetParent.dataset.condType == "orSub") {
          if (condOrIsFull(targetParent.parentNode)) {
            condExpandOrNode(targetParent.parentNode,insideQualifier);
          } 
        }
        
    }

	var icons = document.querySelectorAll('.cond-icon');
	[].forEach.call(icons,function(icon) {
		icon.addEventListener('dragstart', condHandleDragStartCopy, false);
		icon.addEventListener('dragend', condHandleDragEnd, false);
	});

	var blanks = document.querySelectorAll('.cond-empty');
	[].forEach.call(blanks,function(blank) {
		blank.addEventListener('dragover', condHandleDragOverBlank, false);
		blank.addEventListener('drop', condHandleDropOnBlank, false);
	});

	function condHandleDragOverTrash(e) {
		if (e.preventDefault) {
			e.preventDefault();
		}

		if (condDragSource.classList.contains("cond-icon")) {
			e.dataTransfer.dropEffect = "none";
			return false;
		}

		e.dataTransfer.dropEffect = "move";
		return false;
	}

	function condHandleDropOnTrash(e) {
		if (e.preventDefault) {
			e.preventDefault();
		}
    	
		if (condDragSource.classList.contains("cond-icon")) {
			return;
		}

		var sourceParent = condDragSource.parentNode;
		var sourceLabel = condDragSource.dataset.condType == "for" ? 
							condDragSource.previousElementSibling :
							condDragSource.nextElementSibling;
		sourceParent.removeChild(condDragSource);
		sourceParent.removeChild(sourceLabel);
		if ((sourceParent.parentNode) && (sourceParent.parentNode.dataset.condType == "or")) {
			condCleanUpOr(sourceParent.parentNode);
		}
	}

    trashCan = document.getElementById("condTrashIcon");
    trashCan.addEventListener('dragover', condHandleDragOverTrash, false);
    trashCan.addEventListener('drop', condHandleDropOnTrash, false);

    /************************************
     * Functions for Saving and Loading *
     ************************************/

    var valueTypeToChar = {
    	text:'T',
    	date:'Y',
    	checkbox:'X',
    	number:'N'
    }
     
    function condGetConditionString(container) {
    	
    	var outputArray = []
    	function addToOutputArray(str) {
    		return outputArray.push(str);
    	}
    	 
    	function getConditionListStringHelper(condList) {
    		if (condList.length == 0) {
    			return "";
    		} else if (condList.length == 1) {
    			return getConditionStringHelper(condList[0]);
    		} else {
    			var output = "D:";
    			output += "[";
    			for (var i=0; i<condList.length; i++) {
    				output += getConditionStringHelper(condList[i]);
    				output += ",";
    			}
    			output += ']';
    			return addToOutputArray(output);
    		}
    	}
    	function getConditionStringHelper(cond) {
	     	if (cond.classList.contains("cond-empty")) {
				return "";
			} else if (cond.dataset.condType == "atom") {
				var output = "A:";
		    	var lhsVariable = cond.querySelector('select[name="cond-var"]');
		    	output += "V."+lhsVariable.value + ".";
				var op = cond.querySelector('select[name="cond-op"]');
				output += op.value + ".";
		    	var valueCheckbox = cond.querySelector('input[name="cond-value"]')
		    	if (valueCheckbox.checked) {
		    		output += valueTypeToChar[lhsVariable.options[lhsVariable.selectedIndex].dataset.condVarType];
		    		output += "."
					var rhsValue = cond.getElementsByClassName('cond-rhs-value')[0];
		    		output += parseInt(rhsValue.name.slice(14));
		    	} else {
			        output += "V."
		    		var rhsVariable = cond.querySelector('select[name="cond-rhs-var"]');
			        output += rhsVariable.value;
		    	}
		    	return addToOutputArray(output);
			} else if (cond.dataset.condType == "or") {
				var output = "O:";
				var numEmptySubs = condCountEmptyOrSubs(cond);
				var subs = condFilterChildren(cond,function(x){return x.dataset.condType == "orSub";});
				var numNonEmpty = subs.length-numEmptySubs;
				if (numNonEmpty == 0) { // Nothing but empty clauses should just return an empty item.
					return addToOutputArray("E");
				} else if (numNonEmpty == 1) {  // One non-empty clause should just return that clause.
					for (var i=0;i<subs.length;i++) {
						if (!condOrSubIsEmpty(subs[i])) {
							var condList = condFilterChildren(subs[i],function(x){return x.classList.contains("cond-item");});
							return getConditionListStringHelper(condList);
						}
					}
				} else {  // Two or more non-empty clases should result in an OR node.
					output += "[";
					for (var i=0;i<subs.length;i++) {
						if (!condOrSubIsEmpty(subs[i])) {
							var condList = condFilterChildren(subs[i],function(x){return x.classList.contains("cond-item");});
							output += getConditionListStringHelper(condList);
							output += ",";
						}
					}
					output += ']';
				}
				return addToOutputArray(output);
			} else if (cond.dataset.condType == "for") {
				var output = "F:";
				var allOrAny = cond.querySelector('select[name="allOrAny"]');
				if (allOrAny.value == 'all') {
					output += "*.";
				} else {
					output += "1.";
				}
				var type = cond.querySelector('select[name="type"]').value;
				output += type + ".";
				var allOfType = cond.querySelector('input[name="'+type+'-all"]');
				if (allOfType.checked) {
					output += "*";
				} else {
					var choiceListDiv = cond.querySelector('div.cond-'+type+'-selected-list');
					var choices = choiceListDiv.getElementsByClassName("cond-for-list-item");
					output += "[";
					for (var i=0;i<choices.length;i++) {
						output += choices[i].dataset.id + ",";
					}
					output += "]";
				}
				output += ".";
				var insideCondDiv = cond.querySelector('div.cond-for-sub');
				var insideCondList = condFilterChildren(insideCondDiv,function(x){return x.classList.contains("cond-item")});
				if (insideCondList.length == 0) {
					output += "E";
				} else {
					output += getConditionListStringHelper(insideCondList);
				}
				return addToOutputArray(output);
			}
    	}
     	var items = condFilterChildren(container,function(x){return x.classList.contains("cond-item");});
     	var output = getConditionListStringHelper(items) + ";"
     	for (var i = 0; i<outputArray.length; i++) {
     		output += outputArray[i] + ";";
     	}
     	return output;
   	}
   	function condFillCondString() {
   		var container = document.getElementsByClassName("cond-container")[0];
   		var output = condGetConditionString(container);
   		var condString = document.getElementById("cond-cond-string");
   		condString.value=output;
   	}
   	
	var condObjectsNameToId = { {% for objectType in objectTypes %}"{{objectType.name}}":
									{ {% for object in objectType.objects %}"{{object.id}}":"{{object.name}}", {% endfor %} },
								{% endfor %} };
	
   	var initialCond = {{initialCond|safe}};
	var initialEmpty = document.getElementsByClassName("cond-container")[0].getElementsByClassName("cond-empty")[0]
	condCreateUIFromCondition (initialCond,initialEmpty,"none");
	
   	function condCreateUIFromCondition(cond, targetEmpty, insideQualifier) {
   		function selectOptionByValue(sel,val) {
   			var options = sel.options;
   			for (var i=0; i<options.length; i++) {
   				if (options[i].value == val) {
   					sel.selectedIndex = i;
   					return;
   				}
   			}
   		}
   		
   		var targetParent = targetEmpty.parentNode;
   		function createAtom() {
            var atomDiv = condCreateAtomNode(targetParent,targetEmpty,insideQualifier);
            targetParent.removeChild(targetEmpty);
			var op = atomDiv.querySelector('select[name="cond-op"]');
 			selectOptionByValue(op,cond.op);
	    	var lhsVariable = atomDiv.querySelector('select[name="cond-var"]');
			selectOptionByValue(lhsVariable,cond.lhs);
 			var valueCheckBox = atomDiv.querySelector('input[name="cond-value"]')
			if (cond.rhsType == "V") {
				valueCheckBox.checked = false;
	    		var rhsVariable = atomDiv.querySelector('select[name="cond-rhs-var"]');
	    		selectOptionByValue(rhsVariable,cond.rhsvalue);
			} else {
				valueCheckBox.checked = true;
				var charToType = { "X":"checkbox", "Y":"date", "T":"text","N":"number"};
				var rhsValue = atomDiv.getElementsByClassName('cond-rhs-value')[0];
				rhsValue.type = charToType[cond.rhstype];
				rhsValue.value = cond.rhsvalue;
			}
   		}
   		function createAnd() {
   			for (var i=0; i<cond.subConds.length; i++) {
   				var subCond = cond.subConds[i];
   				var empty = targetParent.querySelector('div.cond-empty');
   				condCreateUIFromCondition(subCond,empty,insideQualifier);
   			}
   		}
   		function createOr() {
   			var orDiv = condCreateOrNode(targetParent,targetEmpty,insideQualifier);
   			targetParent.removeChild(targetEmpty)
   			var lastOrSub = orDiv.querySelector('div.cond-or-sub');
   			for (var i=0; i<cond.subConds.length; i++) {
   				var subCond = cond.subConds[i];
   				var empty = lastOrSub.querySelector('div.cond-empty');
   				condCreateUIFromCondition(subCond,empty,insideQualifier);
   				if (i==0) {
   					lastOrSub = orDiv.querySelectorAll('div.cond-or-sub')[1];
   				} else {
   					lastOrSub = condExpandOrNode(orDiv,insideQualifier);
   				}
   			}
   		}
   		function createFor() {
   			var forDiv = condCreateForAllNode(targetParent,targetEmpty);
			var allOrAny = forDiv.querySelector('select[name="allOrAny"]');
			selectOptionByValue(allOrAny,cond.allOrAny.toLowerCase());
			var typeSelector = forDiv.querySelector('select[name="type"]');
			selectOptionByValue(typeSelector,cond.objectType);
			var listDiv = forDiv.querySelector('div.cond-'+cond.objectType+'-selected-list');
			for (var i=0;i<cond.objects.length;i++) {
				condAddThingieToListByNameAndId(listDiv,condObjectsNameToId[cond.objectType][cond.objects[i]],cond.objects[i])
			}
			var empty = forDiv.getElementsByClassName("cond-empty")[0];
			condCreateUIFromCondition(cond.subCond,empty,cond.objectType);
   		}
   		
   		if (cond.type == "EMPTY") {
   			condCreateAtomNode(targetParent,targetEmpty,insideQualifier);
   			targetParent.removeChild(targetEmpty);
   		} else if (cond.type == "ATOM") {
   			createAtom();
   		} else if (cond.type == "AND") {
   			createAnd();
   		} else if (cond.type == "OR") {
   			createOr();
   		} else if (cond.type == "FOR") {
   			createFor();
   		}
   	}
    </script>

