<!DOCTYPE html>
<html>
  <head>
    <title>Prototype of the Condition Interface for OneUp</title>
 
    <style>
      .cond-prototype {
        display: none;
      }
      .cond-item {
        border-style: solid;
        border-width: 1px;
        border-radius: 6px;
        border-color: dimgray;
        text-align: center;
        padding: 2px;
      }
      .cond-empty {
        border-style: dashed;
        border-width: 1px;
        border-radius: 6px;
        border-color: dimgray;
        text-align: center;
        min-width: 20px;
      }
      .cond-container {
        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        justify-content: flex-start;
        align-items: stretch;
        align-content: flex-start;
        height: 400px;
        width: 100%;
        overflow-x: auto;
      }
      .cond-icon-list {
        display: flex;
        flex-direction: row:
        align-items: stretch;
      }
      .cond-icon {
        border-style: solid;
        border-width: 1px;
        border-radius: 6px;
        padding: 6px;
      }
      .cond-trash {
        margin-left: auto;
      }
      .cond-or {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        align-items: center;
        overflow-x: auto;
        overflow-y: hidden;
        background-color: #DDFFFF;
      }
      .cond-or-sub {
        flex-basis: 45%;
        height: 100%;
      }
      .cond-or-label {
        color: silver;
        flex-basis: 8%;
        text-align: center;
      }
      .cond-and-label {
        font-size: 0.6em;
        color: silver;
        text-align: center;
      }
      .cond-atom-option-group {
      }
      .cond-for {
        background-color: yellow;
        align-items: center;
        display: flex;
        flex-direction: column;
      }
      .cond-for-list {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
      }
      .cond-for-list-item {
        padding: 2px;
        background-color: orange;
      }
      .cond-for-sub {
        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        width: 90%;
      }
      .cond-atom {
        background-color: #EEFFEE;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <h1> Some text </h1>
    <p> 
      First we just have some text so that this will look roughly like a
      normal web page and make it clear that the condition part is embedded
      in the middle and not a page unto itself.  This isn't really
      necessary, I wouldn't think, but I'm doing it anyway, because I want to.
      Probably no one will really read this anyway.
    </p>

    <form>
    <p>
      Hidden prototypes live between here.
    </p>
    <div id="condOrPrototype" class="cond-prototype">
      <div class="cond-or cond-item" data-cond-type="or" draggable="true">
		<div class="cond-or-sub" data-cond-type="orSub">
	  	  <div class="cond-empty" data-cond-type="orBlank">&nbsp;</div>
	    </div>
		<div class="cond-or-label">OR</div>
		<div class="cond-or-sub" data-cond-type="orSub">
	  	  <div class="cond-empty" data-cond-type="orBlank">&nbsp;</div>
		</div>
      </div>
    </div>
    <div id="condEmptyOrSubPrototype" class="cond-prototype">
      <div class="cond-or-sub" data-cond-type="orSub">
		<div class="cond-empty" data-cond-type="orBlank">&nbsp;</div>
      </div>
    </div>
    <div id="condOrLabelPrototype" class="cond-prototype">
      <div class="cond-or-label">OR</div>
    </div>
    <div id="condAtomPrototype" class="cond-prototype">
      <div class="cond-item cond-atom" data-cond-type="atom" draggable="true">
		<select name="cond-var" onchange="condChangeAtomToMatchType(this);return true;">
	  	  <option value="0" data-cond-var-type="text" data-cond-context-global="true" data-cond-context-challenge="true" data-cond-context-activity="true">choose a variable</option>
	  	  <option value="1" data-cond-var-type="number" data-cond-context-challenge="true" data-cond-context-activity="true">score</option>
	  	  <option value="2" data-cond-var-type="date" data-cond-context-challenge="true" data-cond-context-activity="true">completion time</option>
	  	  <option value="3" data-cond-var-type="number" data-cond-context-global="true">badge count</option>
	  	  <option value="4" data-cond-var-type="number" data-cond-context-global="true">days logged in</option>
	  	  <option value="5" data-cond-var-type="number" data-cond-context-challenge="true">questions correct</option>
	  	  <option value="6" data-cond-var-type="checkbox" data-cond-context-activity="true">off campus</option>
		</select>
		<select name="cond-op">
	  	  <option value="=">=</option>
	  	  <option value=">">&gt;</option>
	  	  <option value="<">&lt;</option>
		</select>
		<input type="text" name="cond-rhs-value" class="cond-rhs-value">
		<select name="cond-rhs-var" hidden>
	  	  <option value="0" data-cond-context-global="true" data-cond-context-challenge="true" data-cond-context-activity="true">choose a variable</option>
	  	  <option value="1" data-cond-context-challenge="true" data-cond-context-activity="true">score</option>
	  	  <option value="2" data-cond-context-challenge="true" data-cond-context-activity="true">completion time</option>
	  	  <option value="3" data-cond-context-global="true">badge count</option>
	  	  <option value="4" data-cond-context-global="true">days logged in</option>
	  	  <option value="5" data-cond-context-challenge="true">questions correct</option>
	  	  <option value="6" data-cond-context-activity="true">off campus</option>
		</select>
		<label><input type="checkbox" name="cond-value" checked="true" onchange="condToggleAtomType(this)">value</input></label>
      </div>
    </div>
    <div id="condAndLabelPrototype" class="cond-prototype">
      <div class="cond-and-label">AND</div>
    </div>
    <div id="condEmptyAndPrototype" class="cond-prototype">
      <div class="cond-empty" data-cond-type="andBlank">&nbsp;</div>
    </div>
    <div id="condForPrototype" class="cond-prototype">
      <div class="cond-for cond-item" data-cond-type="for" 
		   data-inside-qualifier="challenge" draggable="true">
		<div>
		  	for
		  	<select name="allOrAny">
		   	 	<option value="all">each</option>
		    	<option value="any">any</option>
		  	</select>
		  	of the following
		  	<select name="type" onchange="condChangeForAllType(this);return true;"
				  data-cond-old-type="challenge">
		    	<option value="challenge">challenges</option>
		    	<option value="activity">activities</option>
		  	</select>
		</div>
		<div class="cond-challenge-list">
		  <select name="challenge-list" 
			  onchange="condAddThingieToList(this);this.selectedIndex=0;">
	    	<option value="0">select challenges to add</option>
		    <option value="1">challenge 1</option>
		    <option value="2">challenge 2</option>
	   		<option value="3">challenge 3</option>
	  	  </select>
	  	  or <input type="checkbox" name="challenge-all">
		  <label for="challenge-all">all challenges</label>
		</div>
		<div class="cond-for-list cond-challenge-selected-list">
		</div>  
		<div class="cond-activity-list" hidden>
	  	  <select name="list"
		  	onchange="condAddThingieToList(this);this.selectedIndex=0;">
	    	<option value="0">select activities to add</option>
	    	<option value="1">activity 1</option>
	    	<option value="2">activity 2</option>
	    	<option value="3">activity 3</option>
	  	  </select>
	  	  or <input type="checkbox" name="activity-all">
	  	  <label for="all">all activities</label>
		</div>
		<div class="cond-for-list cond-activity-selected-list">
		</div>  
		<div class="cond-for-sub">
	  		<div class="cond-empty">&nbsp;</div>
		</div>
      </div>
    </div>
    <p>
      And here
    </p>

    <p>
    <div class="cond-icon-list">
      <div id="condOrIcon" class="cond-icon" draggable="true">OR</div>
      <div id="condAtomIcon" class="cond-icon" draggable="true">Atom</div>
      <div id="condForAllIcon" class="cond-icon" draggable="true">Forall</div>
      <div id="condTrashIcon" class="cond-icon cond-trash"> Trash </div>
    </div>
    </p>

    <div class="cond-container cond-item">
      <input type="hidden" value="0" class="cond-atom-count" name="cond-atom-count">
      <div class="cond-empty" data-cond-inside-qualifier="none">&nbsp;</div>
    </div>

    <script>
      function condFilterChildren(node,proposition) {
    	  var output = [];
    	  for (var i=0;i<node.children.length;i++) {
    		  if (proposition(node.children[i])) {
    			  output.push(node.children[i]);
    		  }
    	  }
    	  return output;
      }
    
      function condToggleAtomType(x) {
    	  var atom = x.parentNode.parentNode;
    	  var value = atom.querySelector('input.cond-rhs-value');
          var variable = atom.querySelector('select[name="cond-rhs-var"]');
    	  if (x.checked) {
    		  variable.hidden = true;
    		  value.removeAttribute("hidden");
    	  } else {
    		  value.hidden = true;
    		  variable.removeAttribute("hidden");
    	  }
      }
    
      function condChangeAtomToMatchType(select) {
    	  console.log ("Called! on");
    	  console.log(select);
    	  var atom = select.parentNode.parentNode;
    	  var option = select.options[select.selectedIndex];
    	  var type = option.dataset.condVarType;
    	  var value = atom.querySelector('input.cond-rhs-value');
    	  value.type = type;
    	  
    	  function disable(opt) {
    		  opt.hidden = "true";
    	  }
    	  function enable(opt) {
    		  opt.removeAttribute("hidden");
    	  }
    	  var justEqual = { "=":enable, ">":disable, "<":disable };
    	  var allOps = { "=":enable, ">":enable, "<":enable };
    	  var typeStatusChange = { text: justEqual, date: allOps, number: allOps, checkbox: justEqual };
    	  
    	  var operator = atom.querySelector('select[name="cond-op"]');
    	  for (var i = 0; i<operator.options.length; i++) {
    		  typeStatusChange[type][operator.options[i].value](operator.options[i]);
    	  }
      }
      
      // All names prefixed with cond to decrease odds of any sort
      // of name-space conflict on import.

      /******************************************
       * Functions for handling ForAll UI stuff *
       ******************************************/
      
      function condAddThingieToListByNameAndId(list,name,id) {
        var itemDiv = document.createElement("div");
        itemDiv.onclick = function(e){condRemoveThingie(this)};
        itemDiv.dataset.id = id;
        itemDiv.className = "cond-for-list-item";
        var name_text = document.createTextNode(name+" \u00D7");
        itemDiv.appendChild(name_text);
        list.appendChild(itemDiv);
      }

      function condAddThingieToList(select) {
        var choice = select.options[select.selectedIndex];
        var list = select.parentNode.nextElementSibling;
        var listOfIds = [];
        for (var i = 0; i<list.children.length; i++) { //>
          listOfIds.push(list.children[i].dataset.id);
        }
        if (!listOfIds.includes(choice.value)) {
          condAddThingieToListByNameAndId(list,choice.text,choice.value);
        }
      }

      function condRemoveThingie(item) {
        item.parentNode.removeChild(item);
      }

      var condForAllTypeList = ["challenge","activity",]
      function condChangeForAllType(select) {
        var currentType = select.options[select.selectedIndex].value;
        var oldType = select.dataset.condOldType;
        if (currentType == oldType) {
          return;
        }
        select.dataset.condOldType = currentType;
        var forAllDiv = select.parentNode.parentNode
        var listDivs = {};
        var selectedDivs = {};
        for (var i=0; i<condForAllTypeList.length; i++) {
        	var typeI = condForAllTypeList[i];
        	listDivs[typeI] = forAllDiv.getElementsByClassName("cond-"+typeI+"-list")[0];
       		selectedDivs[typeI] = forAllDiv.getElementsByClassName("cond-"+typeI+"-selected-list")[0];
        }
        listDivs[oldType].hidden = "true";
        selectedDivs[oldType].hidden = "true";
        selectedDivs[oldType].style.display = "none";
        listDivs[currentType].removeAttribute("hidden");
        selectedDivs[currentType].removeAttribute("hidden");
        selectedDivs[currentType].style.display = "flex";

        var subDivs = forAllDiv.getElementsByTagName("DIV");
        [].forEach.call(subDivs,function(subDiv) {
          subDiv.dataset.condInsideQualifier = currentType;
        });
        
        condUpdateAtomSelectForContext(forAllDiv,currentType);
        
        return true;
      }

      /*********************************************
       * Functions relating to draggable interface *
       *********************************************/

      var condDragSource = null;
      var condSourceType = null;

      // The two condHandleDragStart functions are used to set up
      // visual effects and note the drag source when a drag event begins.

      // This one is used for the icons at the top which will be copied
      // into the condition container.
      function condHandleDragStartCopy(e) {
        this.style.opacity = 0.4;
        condDragSource = this;
        condSourceType = "copy";
        e.dataTransfer.effectAllowed = "copy";

        e.stopPropagation();
      }

      // This one is used for the parts of the condition itself which
      // can be dragged around in order to redo things.
      function condHandleDragStartMove(e) {
        this.style.opacity = 0.4;
        if (!this.id) {
          this.id = "cond-id-"+(Date.now()+Math.random()).toString(36);
        }
        condDragSource = this;
        condSourceType = "move";
        e.dataTransfer.effectAllowed = "move";

        e.stopPropagation();
      }
      function condHandleDragEnd(e) {
        this.style.opacity = 1.0;
      }

      function condCanDropOn(source,target) {
        var canDrop = true;
        if ((target.dataset.condType=="orBlank") && 
            (source.id=="condOrIcon")) {
          canDrop = false;
        }

        if ((target.dataset.condInsideQualifier!="none") &&
            (source.id=="condForAllIcon")) {
          canDrop = false;
        }

        if (target.parentNode == source.parentNode) {
          canDrop = false;
        }

        if ((target.dataset.condInsideQualifier!="none") &&
            (source.dataset.condType=="for")) {
          canDrop = false;
        }

        var targetAncestor = target;
        while (targetAncestor.parentNode) {
          if (source == targetAncestor) {
            canDrop = false;
          }
          targetAncestor = targetAncestor.parentNode;
        }
          
        return canDrop;

      }

      function condHandleDragOverBlank(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }

        if (!condCanDropOn(condDragSource,this)) {
          e.dataTransfer.dropEffect = "none";
          return false;
        }

        e.dataTransfer.dropEffect = condSourceType;
        return false;
      }

      function clonePrototype(name) {
        var prototypeSuperDiv = document.getElementById(name);
        var prototypeDiv = prototypeSuperDiv.getElementsByTagName('div')[0].cloneNode(true);
        return prototypeDiv;
      }

      function condUpdateAtomSelectForContext(targetDiv,context) {

    	  if (context == "none") {
    		  context = "global";
    	  }
    	  context = context.charAt(0).toUpperCase() + context.slice(1);
    	  var contextAttributeName = "condContext"+context;
    	  
    	  function updateThisSelect(targetSelect,contextAttributeName, rhs) {
        	  var inputs = targetSelect.getElementsByTagName("option");
        	  for (var i = 0; i < inputs.length; i++) {
        		  if (inputs[i].dataset[contextAttributeName] || (rhs && inputs[i].dataset["condContextGlobal"])) {
        			  inputs[i].removeAttribute("hidden");
        		  } else {
        			  inputs[i].hidden = true;
        		  }
        	  }
    	  }
    	  
    	  var selects = targetDiv.getElementsByTagName("select");
          for (var i = 0; i < selects.length; i++) {
        	var curSelect = selects[i];
          	if (curSelect.name == "cond-var") {
          		updateThisSelect(curSelect,contextAttributeName, false);
              	if (!curSelect.options[curSelect.selectedIndex].dataset[contextAttributeName]) {
              		curSelect.selectedIndex = 0;
              	}          		
          	} else if (curSelect.name == "cond-rhs-var") {
          		updateThisSelect(curSelect,contextAttributeName, true);
              	if (!curSelect.options[curSelect.selectedIndex].dataset[contextAttributeName]) {
              		curSelect.selectedIndex = 0;
              	}
          	}
          }
      }
      
      var atomCountInput = document.querySelector('input.cond-atom-count');
      function condCountNewAtom() {
    	  var count = parseInt(atomCountInput.value);
    	  atomCountInput.value=count+1;
    	  return count;
      }
      
      function condCreateAtomNode(targetParent,blank,insideQualifier) {
        var atomDiv = clonePrototype("condAtomPrototype");
        targetParent.insertBefore(atomDiv,blank);
        var labelDiv = clonePrototype("condAndLabelPrototype");
        targetParent.insertBefore(labelDiv,blank);
        var blankDiv = clonePrototype("condEmptyAndPrototype");
        targetParent.insertBefore(blankDiv,blank);
        condPrepareEmptyDescendants(blankDiv,insideQualifier);

        atomDiv.addEventListener("dragstart",condHandleDragStartMove,false);
        atomDiv.addEventListener("dragend",condHandleDragEnd,false);

	  	var value = atomDiv.querySelector('input.cond-rhs-value');
		value.name = "cond-rhs-value"+condCountNewAtom();
        
        condUpdateAtomSelectForContext(atomDiv,insideQualifier);
        
        return atomDiv;
      }
      function condCreateOrNode(targetParent,blank,insideQualifier) {
        var orDiv = clonePrototype("condOrPrototype");
        targetParent.insertBefore(orDiv,blank);
        var labelDiv = clonePrototype("condAndLabelPrototype");
        targetParent.insertBefore(labelDiv,blank);
        var blankDiv = clonePrototype("condEmptyAndPrototype");
        targetParent.insertBefore(blankDiv,blank);
        condPrepareEmptyDescendants(orDiv,insideQualifier);
        condPrepareEmptyDescendants(blankDiv,insideQualifier);

        orDiv.addEventListener("dragstart",condHandleDragStartMove,false);
        orDiv.addEventListener("dragend",condHandleDragEnd,false);

        return orDiv;
      }
      function condExpandOrNode(targetParent,insideQualifier) {
        var labelDiv = clonePrototype("condOrLabelPrototype");
        targetParent.appendChild(labelDiv);
        var blankSubDiv = clonePrototype("condEmptyOrSubPrototype");
        targetParent.appendChild(blankSubDiv);
        condPrepareEmptyDescendants(blankSubDiv,insideQualifier);
      }
      function condCreateForAllNode(targetParent,blank) {
        var blankDiv = clonePrototype("condEmptyAndPrototype");
        targetParent.insertBefore(blankDiv,blank);
        var labelDiv = clonePrototype("condAndLabelPrototype");
        targetParent.insertBefore(labelDiv,blank);
        var forAllDiv = clonePrototype("condForPrototype");
        targetParent.insertBefore(forAllDiv,blank);
        condPrepareEmptyDescendants(blankDiv,"none");
        condPrepareEmptyDescendants(forAllDiv,"challenge");

        forAllDiv.addEventListener("dragstart",condHandleDragStartMove,false);
        forAllDiv.addEventListener("dragend",condHandleDragEnd,false);

        return forAllDiv;
      }

      function condOrIsFull(orNode) {
        return (condCountEmptyOrSubs(orNode) == 0);
      }
      
      function condOrSubIsEmpty(orSubNode) {
    	  return orSubNode.getElementsByClassName("cond-item").length == 0;
      }
      
      function condCountEmptyOrSubs(orNode) {
          var numEmptySubs = 0;
          var orSubs = orNode.getElementsByClassName("cond-or-sub");
          for (var i = 0; i < orSubs.length; i++) {
          	if (condOrSubIsEmpty(orSubs[i])) {
  	    		numEmptySubs++;
  	  		}
          }
          return numEmptySubs;
      }

      function condCleanUpOr(orNode) {
        var orSubs = orNode.getElementsByClassName("cond-or-sub");
        if (orSubs.length == 2) {
          return;
        }
        var emptyCount = 0;
        var subItems = [];
        for (var i = 0; i < orSubs.length; i++) {
          subItems[i] = orSubs[i].getElementsByClassName("cond-item");
          if (subItems[i].length == 0) {
            emptyCount += 1;
          }
        }

        var j = 0;
        while (emptyCount > 1) {
	  if (subItems[j].length == 0) {
            orNode.removeChild(orSubs[j].nextElementSibling);
            orNode.removeChild(orSubs[j]);
	    emptyCount -= 1;
	  }
	  j++;
	}   
      }

      // This function adds event listeners and also sets the flag
      // for whether or not they are inside a qualifier block
      function condPrepareEmptyDescendants(node,insideQualifier) {
        function prepareEmptyDescendantsHelper(node) {
          if (node.nodeName == "DIV") {
            node.dataset.condInsideQualifier = insideQualifier;
            if (node.classList.contains("cond-empty")) {
              node.addEventListener("dragover",condHandleDragOverBlank,false);
              node.addEventListener("drop",condHandleDropOnBlank,false);
            }
          }
          // Recursive call for all children
          [].forEach.call(node.childNodes,prepareEmptyDescendantsHelper);
        }
        prepareEmptyDescendantsHelper(node);
      }

      function condHandleDropOnBlank(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }

        var targetParent = e.target.parentNode;

      // I decided not to put an outline around the OR bits.
/*        if (targetParent.classList.contains("cond-or-sub") &&
             !(targetParent.classList.contains("cond-item"))) {
          targetParent.classList.add("cond-item");
        }*/

        var insideQualifier = e.target.dataset.condInsideQualifier;
        if (condDragSource.id == "condOrIcon") {
          condCreateOrNode(targetParent,e.target,insideQualifier);
          targetParent.removeChild(e.target);
        } else if (condDragSource.id == "condAtomIcon") {
          condCreateAtomNode(targetParent,e.target,insideQualifier);
          targetParent.removeChild(e.target);
        } else if (condDragSource.id == "condForAllIcon") {
          condCreateForAllNode(targetParent,e.target);
          targetParent.removeChild(e.target);
        } else /* a node to be moved */ {
	 	 	var sourceParentIsOr = 
		    	condDragSource.parentNode.parentNode.dataset.condType == "or";
		  	var sourceOr;
		  	if (sourceParentIsOr) {
		    	sourceOr = condDragSource.parentNode.parentNode;
		  	}
	      	if ((condDragSource.dataset.condType == "or") || 
	        	(condDragSource.dataset.condType == "atom")) {
	        	var andLabelDiv = condDragSource.nextElementSibling;
	        	targetParent.insertBefore(condDragSource,e.target);
	        	targetParent.insertBefore(andLabelDiv,e.target);
	      	} else { // for
	        	var sourceAndLabelDiv = condDragSource.previousElementSibling;
	        	if (e.target.nextElementSibling) {
	          		var targetAndLabelDiv = e.target.nextElementSibling;
	          		targetParent.insertBefore(sourceAndLabelDiv,targetAndLabelDiv);
	          		targetParent.insertBefore(condDragSource,targetAndLabelDiv);
	       		} else { // Last on list.
	          		targetParent.appendChild(sourceAndLabelDiv);
	          		targetParent.appendChild(condDragSource);
	        	}
	      	}
		  	if (sourceParentIsOr) {
		    	condCleanUpOr(sourceOr);
		  	}
		  	condUpdateAtomSelectForContext(condDragSource,insideQualifier);
        }

        if (targetParent.dataset.condType == "orSub") {
          if (condOrIsFull(targetParent.parentNode)) {
            condExpandOrNode(targetParent.parentNode,insideQualifier);
          } 
        }
        
      }
      
      var icons = document.querySelectorAll('.cond-icon');
      [].forEach.call(icons,function(icon) {
        icon.addEventListener('dragstart', condHandleDragStartCopy, false);
        icon.addEventListener('dragend', condHandleDragEnd, false);
      });

      var blanks = document.querySelectorAll('.cond-empty');
      [].forEach.call(blanks,function(blank) {
        blank.addEventListener('dragover', condHandleDragOverBlank, false);
        blank.addEventListener('drop', condHandleDropOnBlank, false);
      });

/*>*/ 
      function condHandleDragOverTrash(e) {
	if (e.preventDefault) {
          e.preventDefault();
	}
	if (condDragSource.classList.contains("cond-icon")) {
	  e.dataTransfer.dropEffect = "none";
	  return false;
	}

        e.dataTransfer.dropEffect = "move";
	return false;
      }
      function condHandleDropOnTrash(e) {
	var sourceParent = condDragSource.parentNode;
	var sourceLabel = 
	  condDragSource.dataset.condType == "for" ? 
	    condDragSource.previousElementSibling :
	    condDragSource.nextElementSibling;
	sourceParent.removeChild(condDragSource);
	sourceParent.removeChild(sourceLabel);
	if ((sourceParent.parentNode) && 
	    (sourceParent.parentNode.dataset.condType == "or")) {
	  condCleanUpOr(sourceParent.parentNode);
	}
      }

    trashCan = document.getElementById("condTrashIcon");
    trashCan.addEventListener('dragover', condHandleDragOverTrash, false);
    trashCan.addEventListener('drop', condHandleDropOnTrash, false);

    /************************************
     * Functions for Saving and Loading *
     ************************************/

    var valueTypeToChar = {
    	text:'T',
    	date:'Y',
    	checkbox:'X',
    	number:'N'
    }
     
    function condGetConditionStringAndDataTable(container) {
    	function getConditionListStringHelper(condList) {
    		if (condList.length == 0) {
    			return "";
    		} else if (condList.length == 1) {
    			return getConditionStringHelper(condList[0]);
    		} else {
    			var output = "D:";
    			output += condList.length;
    			output += "[";
    			for (var i=0; i<condList.length; i++) {
    				output += getConditionStringHelper(condList[i]);
    				output += ",";
    			}
    			output += ']';
    			return output;
    		}
    	}
    	function getConditionStringHelper(cond) {
	     	if (cond.classList.contains("cond-empty")) {
				return "";
			} else if (cond.dataset.condType == "atom") {
				var output = "A:";
		    	var lhsVariable = cond.querySelector('select[name="cond-var"]');
		    	output += lhsVariable.value + ".";
				var op = cond.querySelector('select[name="cond-op"]');
				output += op.value + ".";
		    	var valueCheckbox = cond.querySelector('input[name="cond-value"]')
		    	if (valueCheckbox.checked) {
		    		output += valueTypeToChar[lhsVariable.options[lhsVariable.selectedIndex].dataset.condVarType];
		    		output += "."
					var rhsValue = cond.querySelector('input.cond-rhs-value');
		    		output += parseInt(rhsValue.name.slice(14));
		    	} else {
			        output += "V."
		    		var rhsVariable = cond.querySelector('select[name="cond-rhs-var"]');
			        output += rhsVariable.value;
		    	}
		    	return output;
			} else if (cond.dataset.condType == "or") {
				var output = "O:";
				var numEmptySubs = condCountEmptyOrSubs(cond);
				var subs = condFilterChildren(cond,function(x){return x.dataset.condType == "orSub";});
				var numNonEmpty = subs.length-numEmptySubs;
				if (numNonEmpty == 0) { // Nothing but empty clauses should just return an empty item.
					return "E";
				} else if (numNonEmpty == 1) {  // One non-empty clause should just return that clause.
					for (var i=0;i<subs.length;i++) {
						if (!condOrSubIsEmpty(subs[i])) {
							var condList = condFilterChildren(subs[i],function(x){return x.classList.contains("cond-item");});
							return getConditionListStringHelper(condList);
						}
					}
				} else {  // Two or more non-empty clases should result in an OR node.
					output += numNonEmpty + "[";
					for (var i=0;i<subs.length;i++) {
						if (!condOrSubIsEmpty(subs[i])) {
							var condList = condFilterChildren(subs[i],function(x){return x.classList.contains("cond-item");});
							output += getConditionListStringHelper(condList);
							output += ",";
						}
					}
				}
				output += ']';
				return output;
			} else if (cond.dataset.condType == "for") {
				var output = "F:";
				var allOrAny = cond.querySelector('select[name="allOrAny"]');
				if (allOrAny.value == 'all') {
					output += "*.";
				} else {
					output += "1.";
				}
				var type = cond.querySelector('select[name="type"]').value;
				output += type + ".";
				var allOfType = cond.querySelector('input[name="'+type+'-all"]');
				if (allOfType.checked) {
					output += "*";
				} else {
					var choiceListDiv = cond.querySelector('div.cond-'+type+'-selected-list');
					var choices = choiceListDiv.getElementsByClassName("cond-for-list-item");
					output += choices.length+"[";
					for (var i=0;i<choices.length;i++) {
						output += choices[i].dataset.id + ",";
					}
					output += "]";
				}
				output += ".";
				var insideCondDiv = cond.querySelector('div.cond-for-sub');
				var insideCondList = condFilterChildren(insideCondDiv,function(x){return x.classList.contains("cond-item")});
				if (insideCondList.length == 0) {
					output += "E";
				} else {
					output += getConditionListStringHelper(insideCondList);
				}
				return output;
			}
    	}
     	var items = condFilterChildren(container,function(x){return x.classList.contains("cond-item");});
     	return getConditionListStringHelper(items);
   	}
   	function testItOut() {
   		var container = document.getElementsByClassName("cond-container")[0];
   		var output = condGetConditionStringAndDataTable(container);
   		console.log(output);
   	}
    </script>
  </body>
</html>
